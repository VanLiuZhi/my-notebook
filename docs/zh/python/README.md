---
sidebarDepth: 2
---

# Python 笔记

基础永远是重中之重，虽然在应用开发中，很少会去使用语言的一些特性，比如一些高级话题，描述符，元类。但是掌握这些可以帮助理解框架源代码，从更深层次理解语言。

## callable(object)

检查对象object是否可调用。如果返回True，object仍然可能调用失败；但如果返回False，调用对象ojbect绝对不会成功。
- 注意：类是可调用的，而类的实例实现了__call__()方法才可调用。
- 版本：该函数在python2.x版本中都可用。但是在python3.0版本中被移除，而在python3.2以后版本中被重新添加。

## 继承一个类

如果已经定义了Person类，需要定义新的Student和Teacher类时，可以直接从Person类继承：

<HightCode>
<template>
class Person(object):
    def __init__(self, name, gender):
        self.name = name
        self.gender = gender
</template>
</HightCode>

定义Student类时，只需要把额外的属性加上，例如score：

<HightCode>
<template>
class Student(Person):
    def __init__(self, name, gender, score):
        super(Student, self).__init__(name, gender)
        self.score = score
</template>
</HightCode>

一定要用 `super(Student, self).__init__(name, gender)` 去初始化父类，否则，继承自 Person 的 Student 将没有 name 和 gender。
函数 `super(Student, self)` 将返回当前类继承的父类，即 Person ，然后调用__init__()方法，注意self参数已在super()中传入，在__init__()中将隐式传递，不需要写出（也不能写）。

`super(Teacher,self).__init__(name,gender)` 和 `Person.__init__(self,name,gender)` 等价的，二者选一就好。

假如一个类C继承了类A和类B，类A和类B有不同的属性，并且类C在创建时要初始化这些属性，此时在类C的构造函数__init__中使用super(C，self).__init__调用就无法实现了

<HightCode>
<template>
class A(object):
    def __init__(self, a):
        self.a = a
class B(object):
    def __init__(self, b):
        self.b = b
class C(A, B):
    def __init__(self, a, b):
        super(C, self).__init__(a, b)  # <----这样写是错误的

</template>
</HightCode>

正确的写法:

<HightCode>
<template>
class C(A, B):
    def __init__(self, a, b):
        A.__init__(self, a)
        B.__init__(self, b)

</template>
</HightCode>

**建议养成习惯，不要使用super()这个函数，即便是单继承，也使用上面的方式**

## 反射 & 自省

当执行对象的方法，或者对某个字段赋值的时候，你要操作的字段名或者方法名在编码的时候不确定，这时候需要通过某种机制访问未知的属性。

这个机制被称为反射（反过来让对象告诉我们他是什么），或是自省（让对象自己告诉我们他是什么）。

1. 使用反射获取到的函数和方法可以像平常一样加上括号直接调用
2. 获取到类后可以直接构造实例
3. 不过获取到的字段不能直接赋值，因为拿到的其实是另一个指向同一个地方的引用，赋值只能改变当前的这个引用而已

## 单下划线/双下划线

Python 用下划线作为变量前缀和后缀指定特殊变量/方法。

主要存在四种情形：
1. `object` # public
2. `__object__` # special, python system use, user should not define like it
3. `__object` # private (name mangling during runtime)
4. `_object` # obey python coding convention, consider it as private;

核心风格：避免用下划线作为变量名的开始。

因为下划线对解释器有特殊的意义，而且是内建标识符所使用的符号，我们建议程序员避免用下划线作为变量名的开始。一般来讲，变量名 `_object` 被看作是“私有 的”，在模块或类外不可以使用，不能用 `'from moduleimport *'` 导入。当变量是私有的时候，用 `_object` 来表示变量是很好的习惯。因为变量名 `__object__` 对Python来说有特殊含义，对于普通的变量应当避免这种命名风格。

python有关private的描述，python中不存在protected的概念，要么是public要么就是private，但是python中的private不像C++, Java那样，它并不是真正意义上的private，通过name mangling（名称改编(目的就是以防子类意外重写基类的方法或者属性)，即前面加上“单下划线”+类名,eg：_Class__object）机制就可以访问private了。

"单下划线" 开始的成员变量叫做保护变量，意思是只有类对象和子类对象自己能访问到这些变量；"双下划线" 开始的是私有成员，意思是只有类对象自己能访问，连子类对象也不能访问到这个数据。(如下列所示)
以单下划线开头 `（_foo）` 的代表不能直接访问的类属性，需通过类提供的接口进行访问，不能用 `“from xxx import *”` 而导入；以双下划线开头的 `（__foo）` 代表类的私有成员；以双下划线开头和结尾的 `（__foo__）` 代表python里特殊方法专用的标识，如 `__init__（）` 代表类的构造函数。

变量轧压：Python把以两个或以上下划线字符开头且没有以两个或以上下划线结尾的变量当作私有变量。私有变量会在代码生成之前被转换为长格式（变为公有）。转换机制是这样的：在变量前端插入类名，再在前端加入一个下划线字符。这就是所谓的私有 `变量轧压`（Private name mangling）。

注意：
- 一是因为轧压会使标识符变长，当超过255的时候，Python会切断，要注意因此引起的命名冲突。
- 二是当类名全部以下划线命名的时候，Python就不再执行轧压。

## 特殊方法

| name          | Description
| :-----------: | :---------------
| `__class__`   | 类对象的类型
| `__name__`    | 在模块外和类中代表不同的含义，类中调用返回类名（str），只能类调用，实例调用：`self.__class__.__name__`
| `__doc__`     | 类的文档字符串
| `__bases__`   | 类的所有父类组成的元祖，只能类调用，实例需要通过 `__class__`
| `__dict__`    | 得到一个属性字典，类和实例都可以调用，得到它们对应的属性
| `__module__`  | 类定义所在的模块（类的全名是 `__main__.className`，如果类位于一个导入模块mymod中，那么 `className.__module__` 等于 mymod）
| `__str__`     | 实例来调用，打印实例，输出实例都会执行定义的方法
| `__repr__`    | 实例调用，输出不变，打印变
| `__getattribute__` |  获取属性，针对所有属性运行
| `__getattr__` | 获取属性，针对未定义的属性运行
| `__getitem__` | 字典相关获取属性
| `__slots__`   | 限制实例能绑定的属性

## time

该模块归属在 gengrice operating system services中，接近操作系统底层。围绕着Unix  Timestamp 进行。 需要注意的是在该模块中的大多数函数是调用了所在平台C library的同名函数(比如sleep，其实是调用了平台的C代码)， 所以要特别注意有些函数是平台相关的，可能会在不同的平台有不同的效果。另外一点是，由于是基于Unix Timestamp，所以其所能表述的日期范围被限定在 1970 - 2038 之间，如果你写的代码需要处理在前面所述范围之外的日期，那可能需要考虑使用datetime模块更好。为了解决这个问题，C出里新的标准库代替原来的，这里留个心眼。

## 重定向

在Python中，文件对象sys.stdin、sys.stdout和sys.stderr分别对应解释器的标准输入、标准输出和标准出错流。在程序启动时，这些对象的初值由sys.__stdin__、sys.__stdout__和sys.__stderr__保存，以便用于收尾(finalization)时恢复标准流对象。

print语句默认写入标准输出流，也可重定向至文件或其他可写对象(所有提供write方法的对象)。这样，就可以使用简洁的print语句代替笨拙的object.write('hello'+'\n')写法。因此，在python中调用 print obj 打印对象时，缺省情况下等效于调用sys.stdout.write(obj+'\n').

控制台重定向(>和>>)：
Windows命令提示符(cmd.exe)和Linux Shell(bash等)均通过">"或">>"将输出重定向。其中，">"表示覆盖内容，">>"表示追加内容。类似地，"2>"可重定向标准错误。重定向到"nul"(Windows)或"/dev/null"(Linux)会抑制输出，既不屏显也不存盘。

示例：

    Linux 下
    python print_test.py >>out.txt


## argv 获取输入参数

获取输入参数

```python
import sys
a = sys.argv
print(a)

# 在shell输入python print_test.py 321
# 打印：['print_test.py', '321']
```

## 操作Excel

- xlrd 读取文件，但不能对其进行操作
- xlwt 生成Excel文件（可以用来控制生成的格式），但是不能在已有的Excel文件基础上进行修改
- xluntils 可以修改文件，该模块需要依赖于xlrd，xlwt

```py
wb = Workbook()
ws = wb.active #激活 worksheet，就是创建一张表，表名默认，worksheet就是该表的对象
```

xlwt 中  write_merge(5,6,4,7,'hello')  在第五行，第四列这里输入数据，结果跨1行（5+1），
跨3列（4+3）

openpyxl：也可以用来操作Excel，由于文件格式的原因，在超过最大行数的时候，xlwt将不能处理，这时候可以使用 `openpyxl`

## 内置序列函数

- map(func, seq1[, seq2,…]) 
第一个参数接受一个函数名，后面的参数接受一个或多个可迭代的序列，返回的是一个列表。

- filter(func, seq1[, seq2,…])
用法和map一样，对每个迭代的元素执行func，如果返回结果是真，这个值就留下。

- reduce()
函数接收的参数和 map()类似，一个函数 f，一个list，但行为和 map()不同，reduce()传入的函数 f 必须接收两个参数，reduce()对list的每个元素反复调用函数f，并返回最终结果值。

调用 reduce(f, [1, 3, 5, 7, 9])时，reduce函数将做如下计算：

1. 先计算头两个元素：f(1, 3)，结果为4；
2. 再把结果和第3个元素计算：f(4, 5)，结果为9；
3. 再把结果和第4个元素计算：f(9, 7)，结果为16；
4. 再把结果和第5个元素计算：f(16, 9)，结果为25；
5. 由于没有更多的元素了，计算结束，返回结果25。

上述计算实际上是对 list 的所有元素求和。虽然Python内置了求和函数sum()，但是，利用reduce()求和也很简单。`__iter__`，`__next__` 这个结合，实现一个迭代器，让对象可以迭代。

- zip([iterable, ...])
zip()是Python的一个内建函数，它接受一系列可迭代的对象作为参数，将对象中对应的元素打包成一个个tuple（元组），然后返回由这些tuples组成的list（列表）。若传入参数的长度不等，则返回list的长度和参数中长度最短的对象相同。利用*号操作符，可以将list unzip（解压）。

```s
>>> a = [1,2,3]
>>> b = [4,5,6]
>>> c = [4,5,6,7,8]
>>> zipped = zip(a,b)
[(1, 4), (2, 5), (3, 6)]
>>> zip(a,c)
[(1, 4), (2, 5), (3, 6)]
>>> zip(*zipped)
[(1, 2, 3), (4, 5, 6)]
```

## 时间模块

- utc时区：协调世界时，又称世界统一时间，世界标准时间，国际协调时间，简称UTC 不属于任意时区

- 中国大陆、中国香港、中国澳门、中国台湾、蒙古国、新加坡、马来西亚、菲律宾、西澳大利亚州的时间与UTC的时差均为+8，也就是UTC+8。

- 时间模块有调用操作系统底层的函数，所以你直接看源码看不出什么东西来，源码上的函数是对应到底层的，这个函数真正的实现在底层。

- 一般用time, datetime这两个模块。

1. time
该模块一般用的少

- 获取时间戳：time.time()
- 由给定的时间返回时间戳：time.mktime(t)，t是一个时间元组。先设一个时间元组，9个参数，最后3位可为0：

```py
t = (2016,7,21,22,47,45,0,0,0）
```

- 英文显示：time.asctime(t)
- 格式化结果：time.strftime()，time模块是封装好的一个类，可以理解为直接的time就是时间，但是你不能这么用，得调用类的方法，而strftime方法是将结果格式化的方法
- 时区转换：`time.gmtime()` 将时间戳转换成UTC时区，这里的时间戳就是time.time()

2. datetime
常用的时间对象处理模块

datetime 模块包含了几个常用的模块来处理时间，如date日期，datetime当前日期加上时间

- 获取时间：datetime.datetime.now()

```py
datetime.date.today()
```

- 时间计算（如做加减法，返回几天前的日期）：获取的时间 和 datetime.timedelta(days=1)
做计算，如果是加法就可以得到当前时间一天后的时间，也可传分钟minutes等其它变量，用他们英文的复数形式。

- 时间对象格式化，字符串转换时间对象

strftime：这个函数是时间对象的格式化函数，只要你是时间对象就可以用这个格式化，结果是str

strptime：这个是上面是反着的，将一个字符串转换成时间对象，字符串要和格式化模式一致。比如 `‘2017-8-12’` 对应的格式化模式是 `‘%Y-%m-%d'` 这里的Y如果用小写y，就不对了，小写对应的是 `%y`

- time模块可以直接调用上面的函数
datetime模块你要先创建一个时间对象才能使用上面的函数。因为datetime格式化是类的方法，你要先创建一个实例（时间对象）才能调用方法，而对于time来说这个两个是模块里面的函数，不是类的方法。直接看源码即可理解。

| 格式符	|说明
| :-----:  | ----
| %a	   | 星期的英文单词的缩写：如星期一， 则返回 Mon
| %A	   | 星期的英文单词的全拼：如星期一，返回 Monday
| %b	   | 月份的英文单词的缩写：如一月， 则返回 Jan
| %B	   | 月份的引文单词的缩写：如一月， 则返回 January
| %c	   | 返回datetime的字符串表示，如03/08/15 23:01:26
| %d	   | 返回的是当前时间是当前月的第几天
| %f	   | 微秒的表示： 范围: [0,999999]
| %H	   | 以24小时制表示当前小时
| %I	   | 以12小时制表示当前小时
| %j	   | 返回 当天是当年的第几天 范围[001,366]
| %m	   | 返回月份 范围[0,12]
| %M	   | 返回分钟数 范围 [0,59]
| %P	   | 返回是上午还是下午–AM or PM
| %S	   | 返回秒数 范围 [0,61]。。。手册说明的
| %U	   | 返回当周是当年的第几周 以周日为第一天
| %W	   | 返回当周是当年的第几周 以周一为第一天
| %w	   | 当天在当周的天数，范围为[0, 6]，6表示星期天
| %x	   | 日期的字符串表示 ：03/08/15
| %X	   | 时间的字符串表示 ：23:22:08
| %y	   | 两个数字表示的年份 15
| %Y	   | 四个数字表示的年份 2015
| %z	   | 与utc时间的间隔 （如果是本地时间，返回空字符串）
| %Z	   | 时区名称（如果是本地时间，返回空字符串）

- 时间戳和时间对象转换

```py
d = datetime.datetime.fromtimestamp(timeStamp) 
```

`d.timestapo()`，3.0 datetime模块时间对象的方法，如果是2.0，先把时间对象转换成时间元组，利用time模块的time.mktime(t)也可以得到时间戳。

:sunny:总结：时间对象，时间戳，时间对象格式化成字符串，字符串转换为时间对象，时间对象计算（可以将结果转换成秒，在比较的时候有作用，只要是时间对象，都可以进行算数运算）

## 基本数据结构

1. 基本顺序存储结构——列表与元组

- 切片一般是字符串，不过列表也是可以切片的，从a到b, 这个b可以用负数来做索引。关于倒叙排列 a [ : : -1]，只操作最后一步“步进”

- isdigit()，字符串才有的方法，判断是不是数字

- `a[1:20] = [5]` 可以对列表某部分切片了进行值修改，属于在原处修改

- 复制（浅拷贝）`s[:]   or  s.copy()`

- `s.extend(t)  or  s += t` 在后面插入一组，相当于 `+=`

- `s.insert(i, x)` 在i处插入x (等价于 `s[i:i] = [x]`)

- 清空：`del s[:]   or   s.clear()`

- 删除：`s.pop([i])` 默认删除尾部元素，否则删除i处的元素，`s.remove(x)` 删除第一个等于x的元素
`s.reverse()` 列表反向

:sunny:上面这几个操作 `pop` 有返回值，其它都没有

2. 基本哈希存储结构——字典

| name                       | description
| -------------------------- | ------------
| len(d)                     | 返回字典元素个数 
| d[key]                     | 返回key对应的value 
| d[key]=value               | 为字典元素赋值，如果没有则增加元素 
| del d[key]                 | 删除字典元素 
| key ind/key not ind        | 查看key是否在d中 
| iter(d)                    | 返回一个迭代器，具有__next__()方法 
| clear()                    | 清空 
| copy()                     | 浅复制 
| fromkeys(seq[,value])      | 以seq作为键，value作为值建立字典，默认value为None 
| get(key[,default])         | 安全的get方法，如果不存在返回default，如果不指定default则报错 
| items()                    | 列出一个键值对的view 
| keys()                     | 列出key的view,通常用于遍历 
| values()                   | Returnanewviewofthedictionary'svalues. 
| pop(key[,default])         | 如果键值key存在与字典中，删除dict[key]，返回dict[key]的value值。key值必须给出。否则，返回default值。如果default值没有过出，就会报出KeyError异常。pop()方法至少接受一个参数，最多接受两个参数。 
| popitem()                  | 弹出一个键值对，为key的哈希序列中的第一个 
| setdefault(key[,default])  | 安全的添加操作，如果存在就返回value不更改值，如果不存在添加一个key:default的表项，default默认为0 
| update([other])            | 更改操作，other可以是键值对的列表或元组（二级的），也可以是字典，用other中的键值对添加到或替换原有键值对 

字符串：`s.upper()` 小写转大写

## __slots__

在类中定义，用来限制类能被绑定的属性。需要注意一些情况：

- 正常使用，没有继承关系，除了限制的属性其它的不能被绑定

- 继承情况，分为两种，一是类定义了 `__slots__`，被其它类继承；二是类继承自其它类，父类没有定义 `__slots__`，而类自己定义了 `__slots__`。

1. 第一种情况下，类自己的slots是可以发挥作用的，但是继承这个类的子类就没有属性绑定限制了，但是子类的 `__slots__`属性是可以访问的（实例和类都可以打印 `__slots__` 子类没定义，打印父类的值，子类定义了，打印子类的值），如果想要父类的绑定限制，需要在子类中定义 `__slots = ()` 一个空元组，这样子类的属性绑定就被触发了，能被添加的属性由父类的元组和子类的元组构成，但是子类是空元组，就是需要子类来显示定义 `__slots__` 来触发熟悉绑定限制。

2. 第二种情况，一个类定义了属性绑定，但是它有继承，这个时候该类的slots是发挥不了作用的。需要父类定义 `__slots = ()` 一个空元组，子类的slots才发挥作用。

<HightCode>
<template>

class C:
    # __slots__ = ('a',)
    __slots__ = ()

    pass

class D(C):
    __slots__ = ('b',)

    pass

</template>
</HightCode>

在应用开发中，也是很少使用slots，一般在看源代码的时候会见到

## 给类添加方法

python的 `MethodType(方法， 实例（如果是给类添加方法，就用None）， 类)` 用来给类或实例绑定方法。
例子：

```py
s = Stuedent()  
s.set_name = MethodType(set_name, s, Student)
```

## 获取项目依赖

`pip freeze > requirements.txt` 获取项目依赖。 `pip instal requirements.txt` 安装依赖。

## eval & exec

可以执行动态的代码，比如给一个字符串计算结果。区别：eval返回结果，exec不返回。这就要注意了，`exec('print 1')` 但是用eval就不行，print 不返回结果，你可以做布尔运算，这样是返回结果的。

## 闭包

```py
def  function(runfun):
    def  fun(runfun):
        runfun()
    return fun
```

记住，当函数function被调用后，就产生一个闭包，闭包是fun，自由变量是runfun。

装饰器：功能函数，原函数，使用装饰器，就是将原函数的引用指向功能函数。由于装饰器是为了给原函数增加功能，所以功能函数实现的时候需要接受一个函数的引用作为参数，这个引用即为原函数。

关于自由变量：

```py
def func1(x):
    def func2(n):
        print x ** n
    return func2
```

当我们 `a = func1(5)`，内嵌的函数得到了自由变量 `5`，虽然func1的调用结束了，但是 `5` 会被记录下来，执行 `a(2)` 得到 `25`。通过闭包得到了一个自由变量，这种是运用了嵌套作用域，如果n的值在func1中赋值了，利用的是默认参数来保留嵌套作用域的状态，在低版本中这样用，当时没有引进E的概念，n按照命名空间的原则查找。保持住状态，是闭包的最大运用（js, python 语言亦如此）记住这个保持住状态，你可能会需要这样的特性来设计程序。

这里就涉及到了python作用域查找，LGB，B是内置，新的版本引入了嵌套作用域，LEGB，查找流程是 `L→B`。

js：Javascript语言特有的"链式作用域"结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。js中用闭包就可以在外部取到函数内部的变量（我会在最外层设置一个全局变量，在这个函数里面去把结果赋值给最外层，这样函数外部可以随时取这个变量，当然有闭包，并且还有这样的需求，最好是用闭包）。

## 命名空间

python 命名空间，用字典来记录。局部命名空间（当前函数），全局命名空间（当前模块），内置命名空间（存放内置函数和异常），理解变量查找顺序。

Python 的一个特别之处在于其赋值操作总是在最里层的作用域。赋值不会复制数据——只是将命名绑定到对象。删除也是如此："del y" 只是从局部作用域的命名空间中删除命名 y 。事实上，所有引入新命名的操作都作用于局部作用域。理解命名空间生命周期。函数的命名空间是属于自己的，递归调用的函数也有自己的命名空间。

## 模块

导入的模块会存储在sys.modules表中，重复导入只要能在表中找到，则从内存中取出，不再去执行导入操作。

在导入这里涉及到了字节码的相关知识：做为顶层文件（被执行的，导入其它模块的文件），我们通常看不到pyc，因为顶层文件的pyc在内部使用后就被丢弃了，而属于被导入的文件会创建pyc，并且保留下来。pyo也是字节码，称为最佳化字节码文件。

不要重复导入一个模块，这样做不到覆盖模块属性，应使用 `reload（）`。不要做两个模块互相导入，如果处理不好逻辑容易出错。`python3  reload` 被移到imp中，需要 `from  imp  import  reload` 才能使用。重载后import的模块对象改变了，会对使用import的有影响，但是重载之前的from不会，因为from是复制。记住对于from，它是复制了模块的变量给了新变量（两个同名），变量已经被复制出来了，reload模块不会影响复制出来的变量。

- 模块是对象，导入后，模块将拥有属性，可以使用自省获取模块属性。对于使用from的导入，要重载，先重载对应模块，在重新执行from

- 递归导入：两个模块相互导入对方。逻辑上处理不对，极其容易发生错误，尽量避免这种导入尤其是在其中还使用from

- 单下划线开头的变量只是不能被from module import *  形式导入，from module import _变量名是可以导入的

- 程序直接执行和导入也是有区别的，第五部分7题（python学习手册4）（对于这些非常绕的概念，没有必要完全理解，实际开发运用我们是不会这样做的，还是那句话，书上讲的不要和实际混淆，例如模块名字和系统名字重复，导致导入失败，既然你都知道了，就不要取同名，也省的使用非常绕的导入方法，就为了同名，还不如重新取个名字）

理解 `from & import`

sys.path

模块的搜索路径，在程序启动时进行配置，自动将顶级文件的主目录（或者指定当前工作目录的一个空字符串）、任何PYTHONPATH目录、已创建的任何 `.pth` 文件路径的内容，标准库目录合并。得到一个目录列表。

对于sys.path 修改环境变量是永久影响的，sys.path.append()在程序结束后失效。

`import from` 是赋值语句

1. import将整个模块对象赋值给一个变量名，
2. from将一个或多个变量名赋值给另一个模块中同名的对象

理解模块对象。记住from是赋值，import是导入。在使用上仍有些许区别（只需理解from是copy就行了，理解2的意义）

- 注意：from的第一步也是普通的导入操作。因此，from总是会把整个模块导入到内存中（如果还没导入的话），无论是从这个文件中复制出多少变量名。它不是你想的只加载你需要的部分，如一个函数，虽然导入全部，但是你没指明的模块还是用不了。可能在效率上差了点，但是影响不大。
- 或者这样理解：from也是导入，先导入，然后将变量复制过来。

**变量的含义一定是由源代码中的赋值语句的位置决定的**

- 使用import导入的模块，它的全局作用域一定是其所在的文件
- 函数绝对无法看见其它函数内的变量名，除非它们从物理上处于这个函数内
- 模块程序代码绝对无法看见其它模块内的变量名，除非明确的进行了导入
- 一段程序的作用域完全由程序所处的文件中实际位置决定，作用域绝不会被函数调用或模块导入影响。（这体现了python的静态作用域，有些语言是动态作用域，作用域依赖于运行期间的调用）

命名空间嵌套：`a.py  b.py  c.py   b导入了a，  c 导入了b，  c中通过b.a可以访问到a模块`。

包：理解 `__all__`，`__init__.py` 跨目录导入的时候就应该用包导入。包文件里面可以赋值和执行代码，会在导入包的时候执行，赋值的变量也会加到命名空间里。这里和执行文件所处的位置有重要关系。

例子：dir1是一个文件夹，下面有包dir2。代码在dir1下执行，可以导入dir2包，`import dir2` 不要这样写 `import dir1.dir2`。若dir1也是一个包，代码在它的上层目录执行，就应该是 `import dir1.dir2`。这样两个包的包文件的代码会被执行，变量也可以取到。

该部分也许用到的较少，实际结合下书607页（python学习手册第四版）内容。主要是：

- 代码的执行位置
- 包文件（只有被导入的包，包文件才被执行，变量才能加到命名空间，如果代码本身处在一个包下，那么这个包的包文件因为你不导入所以不被执行）
- 跨文件：有些时候想从另一个文件中拿一个模块来，此时代码所处的是文件或者包亦无所谓，你跨的目录就得是包，一级一级得包结构下去，而且这个包的上一级目录必须在`sys.path` 中，注意这句话，这个包的上级目录必须在 `sys.path `中，只能到上级目录，把自身（包）加进去就找不到了。A下有 `a，b`，b想拿a，`sys.path` 的路径就要到A，到A/a不可以。若路径只到A的上一级，应该是 `import A.b` Ab都要是包。

注意：sys.path 路径在搜索的时候，是在这个列表上从左到右来进行的。

包相对导入和绝对导入：

绝对就是完整路径，从sys.path路径开始搜索。p2.6默认是相对，p3默认是绝对。这样带来问题，`import  module`，p3默认使用绝对路径，如果是系统模块，则同目录下的包导入失败。

## 模块导入

顶层语句直接被执行，定义的函数将被创建，函数的引用写入内存，变量被创建命名空间，python会检查代码并填充局部命名空间。在python运行那行代码之前，就发现了对变量的赋值，并把它添加到局部命名空间中。

在函数中做这样的语句 `i = i +1`，它的本质为：python 是静态作用域，程序在编译的时候就已经知道了变量作用范围。（在代码中给一个变量赋值的地方决定了这个变量将存在于哪个命名空间，也就是它可见的范围）比如定义函数：
```py
def  func2():
    i = i +1
```
这是一个函数，它被定义了，函数所处的模块被导入，或者自身被执行的时候，就要引入这个函数到内存，并且创建它的命名空间，所以说它是静态作用域，等到做func2()，即执行函数的时候，解释器会知道i是静态作用域。这里 `i = i + 1`，是对 i 进行赋值，记住 i 是被赋值的，所以不是查找变量，i 被加入函数自己的局部作用域，后面的 `i + 1` 是执行语句，函数在创建命名空间时，只管创建，还不执行，等到执行的时候，计算 `i + 1`，因为i 是局部的，该函数没有i 的值，所有会报错。记住命名空间先创建，执行的时候去找变量。
```py
i = 1
def  func2():
    a = i +1
```    
这样是对的, 执行的时候，`i` 在局部没找到，去找全局

但是如果是这样：
```py
i = 1
    def  func2()
    a = i +1
    i = a
```
`i` 会被当成局部变量，导致执行 `a = i+1` 时出错。 `i` 必须要声明才能用，要在函数里面取得外部的i, 可以在开始指定 `global  i`。

## 动态类型与对象引用

变量类型的概念只存在对象中。例如 `a = 3`。创建一个对象来表示 `3`，这个对象由值3和头信息组成，头信息是一个指向 `int` 的对象的指针。它的步骤应该是这样的：

- 创建一个变量a，如果它还没创建的话。
- 进行引用，a变量的引用是对象3。

深刻理解 `变量，对象，引用`
- 变量：变量是一个系统表的元素，拥有指向对象的链接空间
- 对象：对象是分配的一块内存，有足够的空间去表示它们所代表的值
- 引用：是自动形成的从变量到对象的指针
- 引用计数器：对象拥有引用计数器

理解共享引用，两个对象都指向同一个对象

对于赋值，每次都是创建新的引用，但是列表支持在原处修改（修改某个元素，不会创建新的对象，把变量赋值为3，则原来指向列表对象，想再指向整形对象，此时创建的新对象），原处修改的，如果想不改变原来的值，可以进行对象拷贝。

加深：a=3, b=a也是实现了共享引用，和列表一样，但是它不支持在原处修改。

## 多态

python 依赖于类型的行为称为多态。为对象来编写接口，而不是为数据类型来编写接口，注意多态的弊端，如果你的接口某个运算只能使用整形，传字符串就出错了，但是多态的灵活性是一种实实在在的好处，是否需要判断类型，可做权衡。一般说python是动态类型语言。

## 作用域

每次对函数调用都会创建一个新的本地作用域。

理解 `LEGB` 作用域，E中闭包的运用（2.2中加入的功能），这是一种高级的技术，是函数式编程的运用。为了取得函数内部的参数，实现一个闭包，在外部来调用，js中的讲解。

嵌套作用域的变量在嵌套的函数被调用的时候才进行查找，在循环中，会以最后循环的值为准。使用默认参数，避开嵌套作用域查找。

分析一个函数的时候，先分析变量的赋值，看其所处的作用域。即先看这个变量会处于什么
作用域，再去分析代码。

<HightCode>
<template>
def func1(parm1):
    parm1 = parm1
    def func2(s):
        print parm1, s
    return func2
# 这样是正确的
def func1(parm1):
    parm1 = parm1
    def func2(s):
        print parm1, s
        parm1 = parm1 + 1
    return func2
# 这样就出错了，以为函数第一，先创建，第二对赋值的变量创建作用域（静态作用域），
# print 语句等函数执行的时候才去执行，次数需要的参数parm1是局部的（因为下一句赋值的
# 关系），所以程序出错。
</template>
</HightCode>

python3  nonlocal ：

在python2 中只有 `global` 被声明的变量会将作用域变成全局。`nonlocal` 的作用：如果在嵌套函数中赋值，该变量会被判定为局部作用域，如果不先赋值就会出错，如果外层有同名变量，在不改变内层变量名的情况下（内层变量名和外层一样），想引用外层的变量，只有声明变量是 `nonlocal`。其实改个变量名也可以解决事情。

<HightCode>
<template>
def func1(parm1):
    parm1 = parm1
    def func2(s):
        parm2 = parm1
        parm2 = parm2 + 'ss'
        print parm2
    return func2
</template>
</HightCode>

若要 `parm1 = parm1` ,要先 `nonlocal  param1`。局部作用域里的代码可以读外部作用域（包括全局作用域）里的变量，但不能更改它。一旦进行更改，就会将其当成是局部变量。而如果在更改前又进行了读取操作，则会抛出异常。这里的改变，即赋值，给想变的变量赋值（是不行的，只能使用关键字，如果外部有个x，将x进行 `parm = x`，是读取了x的值，后面用parm，不属于改变）

如果上面的例子不好理解nonlocal，可以这样理解：

<HightCode>
<template>
def mufunc():
    a = 123
    def func():
        a = a(标记1)+1
</template>
</HightCode>

在这个函数里面，对于 `func a` 根据上面所学，应该知道这里a是声明，那么a的作用域被确定，当然因为没有赋值变量就引用，是要报错的。为了让a（标记1）可以拿到上层函数的a，就可以使用关键字：

<HightCode>
<template>
def mufunc():
    a = 123
    def func():
        nonlocal a
        a = a(标记1)+1
        # a = 123+1
</template>
</HightCode>

## 函数的参数

- 理解位置参数和关键字参数，针对调用 `*` 和 `**` 接收参数时的使用（编写函数）
- 调用的时候，传递参数也可以用 `*` 和 `**`，python 将进行参数解包
- `function（1，2，a，b=2）`，`*` 得到 `1，2，a`，`**` 得到 `b=2`

keyword-only(python3)在函数定义的时候，跟在 `*`args，或直接用 `*`，后面的参数在调用时，必须用关键字的形式。
```py
def dog(name, host, *, age):
    print(name, host, age)
func(1,2,b=2)
```
理解函数参数是通过赋值传递到函数中，赋值的方式是通过对象引用。

## 链式编程

链式编程 是将多个操作（多行代码）通过点号"."链接在一起成为一句代码。 例如：`a.v.fun( )`

## 函数注释 Function Annotations

python3 新增加的特性，可以对函数增加变量注释，以及返回值注释，然后可以通过 `__annotations__` 获取到注释信息的字典。

注意：使用该特性并不会对参数以及返回值做限制，lambda不支持函数注释

例子：

```py
def func(a: 'x', b: 5 + 6, c: list, *args: 'xx', **kwargs: float) -> max(2, 9):
    pass

print(func.__annotations__)
# {'a': 'x', 'b': 11, 'c': <class 'list'>, 'args': 'xx', 'kwargs': <class 'float'>, 'return': 9}
```

## lambda
也称为匿名函数（因为没有函数名）

特性：是一个表达式，而不是一个语句；主体是一个单个的表达式，而不是一个代码块，只能编写简单的函数，不能用像if这样的语句（但可以写if关联的表达式）。由于是表达式，可以出现在列表中，def不能。一个表达式，得到的是函数的引用。

## 文件流与二进制流

`stringIO  BytesIO`，文本流的文件（txt,world,excel）才用StringIO，二进制流（视频，图片）用BytesIO

## 动态载入模块

可能会有需求根据需要载入不同的模块，利用多态的特性进行程序设计

1. exec()函数
```py
modelname = 'string'
exec('import'+modelname)
```
2. 或者利用 `__import__` （推荐）
```py
modelname = 'string'
string = __import__(modelname)
```

## 面向对象
面向对象相关内容

### 委托

委托的概念，就是你想访问A类的时候，通过B类来访问，一般实现在B类中创建一个私有属性，指向A的实例。

class ：class语句是对象的创建者并且是一个隐含的赋值运算——执行时，它会产生类对象，并把其引用值存储在前面所使用的变量名。就是说，只有代码跑到这里，或者是导入class语句才发挥作用。

注意：一个对象的属性查找顺序遵循首先查找实例对象自己，然后是类，接着是类的父类。如果有一个类变量叫“data”, 实例也有一个变量同名，那么通过self.data去找到的只是实例的，当实例没有这个变量，才会找到类变量。一般类变量访问通过类名来获取。

加深：类本身拥有自己的类变量（保存在内存），当一个TestClass类的对象被构造时，会将当前类变量拷贝一份给这个对象，当前类变量的值是多少，这个对象拷贝得到的类变量的值就是多少；而且，通过对象来修改类变量，并不会影响其他对象的类变量的值，因为大家都有各自的副本，更不会影响类本身所拥有的那个类变量的值；只有类自己才能改变类本身拥有的类变量的值。
这也是python的特别，不同于C++的静态变量。

理解隐式调用：方法第一个参数总是接收方法调用的隐性主体，也就是实例对象。python会自动把实例方法的调用对应到类方法函数：
instance.method(args...)           class.method(instance, args...)

对于类来说，写在def语句外的都是类变量，想在方法中引用这个变量，需要加上类名。如果变量在class之外，像函数查找变量一样来操作。

类的构造函数可以有多个，但是只会使用最后一个

在python中，当对对象进行点号运算时，就会发生继承，而且涉及了搜索属性定义树（一个或多个命名空间）

类接口技术常用的技巧：超类，继承，重写，扩展，提供（提供者模式）