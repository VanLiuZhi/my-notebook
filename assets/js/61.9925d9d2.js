(window.webpackJsonp=window.webpackJsonp||[]).push([[61],{512:function(t,s,e){"use strict";e.r(s);var n=e(1),a=Object(n.a)({},function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("div",{staticClass:"content"},[e("h1",{attrs:{id:"pytest"}},[t._v("pytest")]),t._v(" "),e("h2",{attrs:{id:"命令"}},[t._v("命令")]),t._v(" "),t._m(0),t._m(1),t._v(" "),t._m(2),e("h2",{attrs:{id:"相关装饰器讲解"}},[t._v("相关装饰器讲解")]),t._v(" "),t._m(3),t._v(" "),e("p",[t._v("这个装饰器会让被装饰的函数只执行一次，通常用来装饰需要在多个测试直接使用到的同一个变量，例如：")]),t._v(" "),t._m(4),e("p",[t._v("把上面的代码放入conftest.py 文件中（经测试这个文件名字不能改，不知道为什么）")]),t._v(" "),e("p",[t._v("这样在其它测试文件中，我们可以把get_result做为参数传入，例如：\n文件  test_func.py")]),t._v(" "),t._m(5),e("p",[t._v("pytest.mark.usefixtures  装饰器的使用，就是显式的调用，先用@pytest.fixture()把需要公用的函数做装饰，使用的时候通过pytest.mark.usefixtures装饰，就可以得到公用函数了，下面展示了使用三种方法：")]),t._v(" "),e("HightCode",[[t._v("\nimport pytest\n@pytest.fixture()\ndef before():\n    print('\\nbefore each test')\n@pytest.mark.usefixtures(\"before\")\ndef test_1():\n    print('test_1()')\n@pytest.mark.usefixtures(\"before\")\ndef test_2():\n    print('test_2()')\nclass Test1:\n    @pytest.mark.usefixtures(\"before\")\n    def test_3(self):\n        print('test_1()')\n    @pytest.mark.usefixtures(\"before\")\n    def test_4(self):\n        print('test_2()')\n@pytest.mark.usefixtures(\"before\")\nclass Test2:\n    def test_5(self):\n        print('test_1()')\n    def test_6(self):\n        print('test_2()')\n")]],2),t._v(" "),e("p",[t._v("关于 fixture 的scope参数")]),t._v(" "),t._m(6),t._v(" "),e("p",[t._v("比如你的所有test都需要连接同一个数据库，那可以设置为module，只需要连接一次数据库，对于module内的所有test，这样可以极大的提高运行效率。")]),t._v(" "),e("p",[t._v("autouse 参数")]),t._v(" "),e("p",[t._v("这个参数默认是Fals, 设置为True的时候，一个session的所有test都会自动调用autouse设置为True的fixture。就是自动调用了，你都不需要把fixture作为参数传入，比如你的fixture写成打印一些友好提示，这样在每个测试执行的时候，这些提示都会打印出来。")])],1)},[function(){var t=this.$createElement,s=this._self._c||t;return s("div",{staticClass:"language-sh extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[this._v("py.test\npy.test --version\npy.test name.py\npy.test --resultlog=report  保存测试报告\n")])])])},function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ul",[e("li",[t._v("测试文件以test_开头（以_test结尾也可以）")]),t._v(" "),e("li",[t._v("测试类以Test开头，并且不能带有 "),e("strong",[t._v("init")]),t._v(" 方法")]),t._v(" "),e("li",[t._v("测试函数以test_开头")]),t._v(" "),e("li",[t._v("断言使用基本的assert即可")])])},function(){var t=this.$createElement,s=this._self._c||t;return s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[this._v('一些命令\npy.test               # run all tests below current dir  \npy.test test_mod.py   # run tests in module  \npy.test somepath      # run all tests below somepath  \npy.test -k stringexpr # only run tests with names that match the  \n                      # the "string expression", e.g. "MyClass and not method"  \n                      # will select TestMyClass.test_something  \n                      # but not TestMyClass.test_method_simple  \npy.test test_mod.py::test_func # only run tests that match the "node ID",  \n                   # e.g "test_mod.py::test_func" will select  \n                               # only test_func in test_mod.py  \n')])])])},function(){var t=this.$createElement,s=this._self._c||t;return s("pre",[s("code",[this._v('@pytest.fixture(scope="module")\n')])])},function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("div",{staticClass:"language-python extra-class"},[e("pre",{pre:!0,attrs:{class:"language-python"}},[e("code",[t._v("@pytest"),e("span",{attrs:{class:"token punctuation"}},[t._v(".")]),t._v("fixture"),e("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("scope"),e("span",{attrs:{class:"token operator"}},[t._v("=")]),e("span",{attrs:{class:"token string"}},[t._v("'module'")]),e("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),e("span",{attrs:{class:"token keyword"}},[t._v("def")]),t._v(" "),e("span",{attrs:{class:"token function"}},[t._v("get_result")]),e("span",{attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),e("span",{attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),e("span",{attrs:{class:"token number"}},[t._v("1")]),t._v("\n")])])])},function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("div",{staticClass:"language-python extra-class"},[e("pre",{pre:!0,attrs:{class:"language-python"}},[e("code",[e("span",{attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),e("span",{attrs:{class:"token class-name"}},[t._v("TestApi")]),e("span",{attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),e("span",{attrs:{class:"token keyword"}},[t._v("def")]),t._v(" "),e("span",{attrs:{class:"token function"}},[t._v("test_func")]),e("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("self"),e("span",{attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" get_result"),e("span",{attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n        a "),e("span",{attrs:{class:"token operator"}},[t._v("=")]),t._v(" get_result\n        "),e("span",{attrs:{class:"token keyword"}},[t._v("assert")]),t._v(" a "),e("span",{attrs:{class:"token operator"}},[t._v("!=")]),t._v(" "),e("span",{attrs:{class:"token number"}},[t._v("1")]),t._v("\n")])])])},function(){var t=this.$createElement,s=this._self._c||t;return s("ul",[s("li",[this._v("function：每个test都运行，默认是function的scope")]),this._v(" "),s("li",[this._v("class：每个class的所有test只运行一次")]),this._v(" "),s("li",[this._v("module：每个module的所有test只运行一次")]),this._v(" "),s("li",[this._v("session：每个session只运行一次")])])}],!1,null,null,null);a.options.__file="pytest.md";s.default=a.exports}}]);