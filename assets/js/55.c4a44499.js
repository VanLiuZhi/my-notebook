(window.webpackJsonp=window.webpackJsonp||[]).push([[55],{506:function(n,t,e){"use strict";e.r(t);var r=e(1),a=Object(r.a)({},function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("div",{staticClass:"content"},[e("h1",{attrs:{id:"线程"}},[n._v("线程")]),n._v(" "),e("p",[n._v("使用标准库threading来创建线程。threading 库可以在单独的线程中执行任何的在 Python 中可以调用的对象。你可 以创建一个 Thread 对象并将你要执行的对象以 target 参数的形式提供给该对象。虽然python GIL 的存在，导致多线程同一时刻只能有一个线程获得解释器（在py2中，大概执行1000行字节码后，会释放解释器，当线程被阻塞的时候，会让出解释器，释放GIL）")]),n._v(" "),e("p",[n._v("可以通过time.sleep(3)来阻塞线程")]),n._v(" "),e("p",[n._v("一个简单例子：")]),n._v(" "),e("highlight-code",{attrs:{lang:"python"}},[e("pre",[e("code",[n._v("import threading\n\n# 计算密集型任务\ndef func():\n    a = [i for i in range(1111)]\n    print('hello world')\n\n\nt = threading.Thread(target=func)\nt.start()\nprint('sleep')\n# 此时创建列表a占用了解释器，先hello world 再 sleep\n\n\n# 计算密集型任务\ndef func():\n    a = [i for i in range(11111111111)]\n    print('hello world')\n\n\nt = threading.Thread(target=func)\nt.start()\nprint('sleep')\n# 这种情况，先打印sleep再是hello world（执行一定的字节码后，释放了解释器）\n")])])]),n._v(" "),e("h2",{attrs:{id:"threading的属性和方法"}},[n._v("threading的属性和方法")]),n._v(" "),n._m(0),n._v(" "),e("p",[n._v("看一个例子：")]),n._v(" "),e("highlight-code",{attrs:{lang:"python"}},[e("pre",[e("code",[n._v("import threading\n\ndef func():\n    # a = [i for i in range(1111)]\n    print('current thread = {}'.format(threading.current_thread()))\n    print('main thread = {}'.format(threading.main_thread()), '\"主线程对象\"')\n    print('active count = {}'.format(threading.active_count()), '\"alive\"')\n    print('hello world')\n\n\nt = threading.Thread(target=func)\nt.start()\nprint('sleep')\nprint('current thread = {}'.format(threading.current_thread()))\nprint('main thread = {}'.format(threading.main_thread()), '\"主线程对象\"')\nprint('active count = {}'.format(threading.active_count()), '\"alive\"')\n")])])]),n._v(" "),e("p",[n._v("运行以上代码，每次的执行结果是不一样的，而且是print是线程不安全的。要解释这个问题，需要再了解一些线程相关的概念。")]),n._v(" "),e("h2",{attrs:{id:"thread实例的属性和方法"}},[n._v("thread实例的属性和方法")]),n._v(" "),n._m(1),n._v(" "),e("p",[n._v("通过threading.Thread()  我们创建了线程类的实例，像面向对象一样，可以有对应的方法，属性")]),n._v(" "),n._m(2),n._v(" "),n._m(3),n._v(" "),e("p",[n._v("开始线程活动。")]),n._v(" "),e("p",[n._v("对每一个线程对象来说它只能被调用一次，它安排对象在一个另外的单独线程中调用run()方法（而非当前所处线程）。\n当该方法在同一个线程对象中被调用超过一次时，会引发RuntimeError(运行时错误)。")]),n._v(" "),n._m(4),n._v(" "),e("p",[n._v("代表了线程活动的方法。")]),n._v(" "),e("p",[n._v("你可以在子类中重写此方法。标准run()方法调用了传递给对象的构造函数的可调对象作为目标参数，如果有这样的参数的话，顺序和关键字参数分别从args和kargs取得。")]),n._v(" "),e("p",[n._v("start() 后，还会执行run。如果你重写线程类，在调用start和run的时候，加入打印代码，start执行的线程，会派生出子线程，在子线程中去执行run，配合threading.current_thread()可以看到整个过程。")]),n._v(" "),e("p",[n._v("而run只在当前线程中执行。")]),n._v(" "),e("h2",{attrs:{id:"多线程情况"}},[n._v("多线程情况")]),n._v(" "),e("p",[n._v("继承Thread类，使用Extender的形式扩展start和run方法，观察执行情况。我们开启两个线程，然后start他们，利用threading.current_thread()获取当前线程，main_thread()返回主线程对象")]),n._v(" "),e("highlight-code",{attrs:{lang:"python"}},[e("pre",[e("code",[n._v("import threading\nimport time\nimport logging\n\nlogging.basicConfig(level=logging.NOTSET)\n\n\ndef worker():\n    count = 0\n    while True:\n        if count > 5:\n            break\n        time.sleep(1)\n        count += 1\n        # print(\"worker running\")\n        logging.info(\"{} {} 主线程：{}\".format(threading.current_thread().name, threading.current_thread().ident,\n                                        threading.main_thread()))\n        # print(threading.current_thread().name, threading.current_thread().ident)\n\n\nclass MyThread(threading.Thread):\n    def start(self):\n        print('start~~~~~~~~~~~~~')\n        super().start()\n\n    def run(self):\n        print('run~~~~~~~~~~~~~~~')\n        super().run()\n\n\nprint(threading.main_thread())\n\nt = MyThread(name='worker', target=worker)\nt2 = MyThread(name='not worker', target=worker)\nt.start()\nt2.start()\nt.join()\nt2.join()\n\n# 输出结果\n# <_MainThread(MainThread, started 4587271616)>\n# start~~~~~~~~~~~~~\n# run~~~~~~~~~~~~~~~\n# start~~~~~~~~~~~~~\n# run~~~~~~~~~~~~~~~\n# INFO:root:worker 123145369858048 主线程：<_MainThread(MainThread, started 4587271616)>\n# INFO:root:not worker 123145375113216 主线程：<_MainThread(MainThread, started 4587271616)>\n# INFO:root:worker 123145369858048 主线程：<_MainThread(MainThread, started 4587271616)>\n# INFO:root:not worker 123145375113216 主线程：<_MainThread(MainThread, started 4587271616)>\n# INFO:root:worker 123145369858048 主线程：<_MainThread(MainThread, started 4587271616)>\n# INFO:root:not worker 123145375113216 主线程：<_MainThread(MainThread, started 4587271616)>\n# INFO:root:worker 123145369858048 主线程：<_MainThread(MainThread, started 4587271616)>\n# INFO:root:not worker 123145375113216 主线程：<_MainThread(MainThread, started 4587271616)>\n# INFO:root:worker 123145369858048 主线程：<_MainThread(MainThread, started 4587271616)>\n# INFO:root:not worker 123145375113216 主线程：<_MainThread(MainThread, started 4587271616)>\n# INFO:root:worker 123145369858048 主线程：<_MainThread(MainThread, started 4587271616)>\n# INFO:root:not worker 123145375113216 主线程：<_MainThread(MainThread, started 4587271616)>\n")])])]),n._v(" "),e("p",[n._v("可以看到两个线程交替运行，如果使用print，你跑多次这个结果是不一样的。")]),n._v(" "),e("p",[n._v("打印前可以加入threading.main_thread()，这样可以看到俩个线程都是主线程派生出来的子线程。")]),n._v(" "),e("p",[n._v("换成run()方法后，结果如下：")]),n._v(" "),e("highlight-code",{attrs:{lang:"python"}},[e("pre",[e("code",[n._v("import threading\nimport time\nimport logging\n\nlogging.basicConfig(level=logging.NOTSET)\n\n\ndef worker():\n    count = 0\n    while True:\n        if count > 5:\n            break\n        time.sleep(1)\n        count += 1\n        # print(\"worker running\")\n        # print(threading.main_thread().name, threading.current_thread().name, threading.current_thread().ident)\n        logging.info(\"{} {} 主线程：{}\".format(threading.current_thread().name, threading.current_thread().ident,\n                                        threading.main_thread()))\n\n\nclass MyThread(threading.Thread):\n    def start(self):\n        print('start~~~~~~~~~~~~~')\n        super().start()\n\n    def run(self):\n        print('run~~~~~~~~~~~~~~~')\n        super().run()\n\n\nt = MyThread(name='worker', target=worker)\nt2 = MyThread(name='not worker', target=worker)\nt.run()\nt2.run()\n\n# run~~~~~~~~~~~~~~~\n# INFO:root:MainThread 4705641920 主线程：<_MainThread(MainThread, started 4705641920)>\n# INFO:root:MainThread 4705641920 主线程：<_MainThread(MainThread, started 4705641920)>\n# INFO:root:MainThread 4705641920 主线程：<_MainThread(MainThread, started 4705641920)>\n# INFO:root:MainThread 4705641920 主线程：<_MainThread(MainThread, started 4705641920)>\n# INFO:root:MainThread 4705641920 主线程：<_MainThread(MainThread, started 4705641920)>\n# run~~~~~~~~~~~~~~~\n# INFO:root:MainThread 4705641920 主线程：<_MainThread(MainThread, started 4705641920)>\n# INFO:root:MainThread 4705641920 主线程：<_MainThread(MainThread, started 4705641920)>\n# INFO:root:MainThread 4705641920 主线程：<_MainThread(MainThread, started 4705641920)>\n# INFO:root:MainThread 4705641920 主线程：<_MainThread(MainThread, started 4705641920)>\n# INFO:root:MainThread 4705641920 主线程：<_MainThread(MainThread, started 4705641920)>\n# INFO:root:MainThread 4705641920 主线程：<_MainThread(MainThread, started 4705641920)>\n# INFO:root:MainThread 4705641920 主线程：<_MainThread(MainThread, started 4705641920)>\n")])])]),n._v(" "),n._m(5),n._v(" "),n._m(6),n._v(" "),e("p",[n._v("当使用start方法启动线程后，进程内有多个活动的线程并行的工作，就是多线程。")]),n._v(" "),n._m(7),n._v(" "),e("h2",{attrs:{id:"线程安全"}},[n._v("线程安全")]),n._v(" "),e("p",[n._v("使用print来运行上面的两个例子，本应该是一行行打印，但很多字符串打印在了一起，这说明print函数被打断了，被线程切换打断了。")]),n._v(" "),e("p",[n._v("print函数分两步，第一步打印字符串，第二部换行，就在这之间，发生了线程的切换。")]),n._v(" "),e("p",[n._v("说明print函数不是线程安全函数。")]),n._v(" "),e("p",[n._v("print函数还没执行换行符，就被其它线程打断了，在python3中：")]),n._v(" "),n._m(8),n._v(" "),e("p",[n._v("print变成了函数，结尾默认加‘\\n’，你可以去改变这个参数，比如改成'', 打印结果就是一行的一串字符")]),n._v(" "),e("p",[n._v("线程安全: 线程执行一段代码，不会产生不确定的结果，那这段代码就是线程安全的。在开发中，我们会使用标准库的logging来，打印信息，这个是线程安全的。")]),n._v(" "),e("h2",{attrs:{id:"线程daemon"}},[n._v("线程daemon")]),n._v(" "),n._m(9),n._v(" "),e("p",[n._v("daemon线程和non-daemon线程(注：这里的daemon不是Linux中的守护进程)：")]),n._v(" "),n._m(10),n._v(" "),e("p",[n._v("daemon属性：表示线程是否是daemon线程，这个值必须在start()之前设置，否则引发RuntimeError异常。")]),n._v(" "),n._m(11),n._v(" "),e("p",[n._v("实例方法：")]),n._v(" "),e("p",[n._v("isDaemon()：是否是daemon线程。\nsetDaemon()：设置为daemon线程，必须在start方法之前设置。")]),n._v(" "),e("p",[n._v("总结:")]),n._v(" "),e("p",[n._v("线程具有一个daemon属性，可以显式设置为True或False，也可以不设置，不设置则取默认值None。")]),n._v(" "),e("p",[n._v("如果不设置daemon，就取当前线程的daemon来设置它。子线程继承父线程的daemon值，作用和设置None一样。")]),n._v(" "),e("p",[n._v("主线程是non-daemon线程，即daemon=False。")]),n._v(" "),e("p",[n._v("从主线程创建的所有线程不设置daemon属性，则默认都是daemon=False，也就是non-daemon线程。")]),n._v(" "),e("p",[n._v("python程序在没有活着的non-daemon线程运行时退出，也就是剩下的只能是daemon线程，主线程才能退出，否则主线程就只能等待。")]),n._v(" "),n._m(12),n._v(" "),n._m(13),n._v(" "),e("p",[n._v("子线程也是non-daemon，只要有线程是non-daemon，python程序就不会退出，如果还未执行完成的线程是daemon的，主线程执行完，就会退出，并杀掉所有daemon线程。")]),n._v(" "),e("p",[n._v("Daemon线程会被粗鲁的直接结束，它所使用的资源（已打开文件、数据库事务等）无法被合理的释放。")]),n._v(" "),e("highlight-code",{attrs:{lang:"python"}},[e("pre",[e("code",[n._v("import time\nimport threading\n\n\ndef foo(n):\n    for i in range(n):\n        print(i)\n        time.sleep(1)\n\n\nt1 = threading.Thread(target=foo, args=(10,), daemon=True)\nt1.start()\n# t1.join()  # 设置join.\nprint('Main Thread Exiting')\n")])])]),n._v(" "),e("p",[n._v("在这个例子中，子线程开始执行，然后主线程执行了打印，由于主线程执行完成了，而剩下的线程是daemon的，所以程序退出。把daemon = False或者不设置，结果就是打印了Main Thread Exiting后，子线程继续，打印1，2，3.....")]),n._v(" "),e("h2",{attrs:{id:"join"}},[n._v("join")]),n._v(" "),n._m(14),n._v(" "),n._m(15),n._v(" "),e("p",[n._v("join ()方法：主线程A中，创建了子线程B，并且在主线程A中调用了B.join()，那么，主线程A会在调用的地方等待，直到子线程B完成操作后，才可以接着往下执行，那么在调用这个线程时可以使用被调用线程的join方法。")]),n._v(" "),e("p",[n._v("总结：")]),n._v(" "),e("p",[n._v("主要理解daemon join，不做处理的多线程，线程是并发的，daemon控制了主线程是否等待子线程执行完成，join控制了线程是否要组赛，主线程被阻塞了，就不会因为还剩daemon线程退出，因为主线程被阻塞了，他还没有执行完，所以这两个概念是互不冲突的（你可以设置超时时间，超时到了，主线程不再阻塞，就会杀掉daemon线程）。")]),n._v(" "),e("p",[n._v("在主线程中创建了3个线程，3个线程执行了join，就是说主线程要等着3个线程完成才执行，3个线程中的A线程创建了线程a，那么a就是A的子线程，a中join A就要等a执行完成，主线程也被阻塞，在等A，即主线程等A，A等a。")]),n._v(" "),e("h2",{attrs:{id:"原子性"}},[n._v("原子性")]),n._v(" "),e("p",[n._v("python的大部分操作是原子性的，比如你对列表执行反向，排序，它不会被其它线程打断。")]),n._v(" "),n._m(16),e("p",[n._v("利用标准库的dis可以看python代码的字节码实现，一般操作由一条指令来完成，那么就是原子性，如果一个操作（对应python的一行或几行代码）需要多个指令（入栈，出栈，调用寄存器等），可能在入栈等某个指令的时候被其它线程打断，出现和预期不一样的效果。")]),n._v(" "),e("h2",{attrs:{id:"队列"}},[n._v("队列")]),n._v(" "),e("p",[n._v("标准库queue提供了队列支持，在py2中，通过import Queue来使用队列，在py3中，通过from queue import Queue，py3中，除了Queue类，还增加了queue.LifoQueue（LIFO后进先出队列），queue.PriorityQueue（优先级队列）")]),n._v(" "),e("h3",{attrs:{id:"实例方法"}},[n._v("实例方法")]),n._v(" "),n._m(17),n._v(" "),n._m(18),n._v(" "),e("h2",{attrs:{id:"本地线程"}},[n._v("本地线程")]),n._v(" "),e("p",[n._v("不同的线程对内容的修改只在线程内发挥作用，线程之间互相不影响")]),n._v(" "),e("highlight-code",{attrs:{lang:"python"}},[e("pre",[e("code",[n._v("import threading\n\nmy_data = threading.local()\nmy_data.number = 42\nprint(my_data.number)\nlog = []\n\ndef f():\n    my_data.number = 11\n    log.append(my_data.number)\n    print(id(my_data.number))\n\nthread = threading.Thread(target=f)\nthread.start()\nthread.join()\nprint(log)\nprint(my_data.number)\nprint(id(my_data.number))\n\n# 42\n# 4559721904\n# [11]\n# 42\n# 4559722896\n")])])]),n._v(" "),e("h2",{attrs:{id:"总结"}},[n._v("总结")]),n._v(" "),e("p",[n._v("所以线程的执行结果是有很多因素影响的，在你用默认操作的时候，如果进行了IO密集任务或是CPU密集任务，IO密集在等待时会释放GIL，CPU密集也会执行一定数量的字节码后释放一下GIL，由于线程并发的切换是操作系统控制的，所以有这样的编程需求的时候，务必配合join，daemon等控制程序，不然什么时候切换，这是说不准的。")]),n._v(" "),e("p",[n._v("线程何时切换？一个线程无论何时开始睡眠或等待网络 I/O，其他线程总有机会获取 GIL 执行 Python 代码。这是协同式多任务处理。CPython 也还有抢占式多任务处理。如果一个线程不间断地在 Python 2 中运行 1000 字节码指令，或者不间断地在 Python 3 运行15 毫秒，那么它便会放弃 GIL，而其他线程可以运行。把这想象成旧日有多个线程但只有一个 CPU 时的时间片。")]),n._v(" "),n._m(19),n._v(" "),e("p",[n._v("让我们回顾下 Python 是如何运行的。你的程序分两个阶段运行。首先，Python文本被编译成一个名为字节码的简单二进制格式。第二，Python解释器的主回路，一个名叫 pyeval_evalframeex() 的函数，流畅地读取字节码，逐个执行其中的指令。当解释器通过字节码时，它会定期放弃GIL，而不需要经过正在执行代码的线程允许，这样其他线程便能运行。默认情况下，检测间隔是1000 字节码。所有线程都运行相同的代码，并以相同的方式定期从他们的锁中抽出。在 Python 3 GIL 的实施更加复杂，检测间隔不是一个固定数目的字节码，而是15 毫秒。然而，对于你的代码，这些差异并不显著。")])],1)},[function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ul",[e("li",[n._v("current_thread()  # 返回当前线程对象.")]),n._v(" "),e("li",[n._v("main_thread()  # 返回主线程对象.")]),n._v(" "),e("li",[n._v("active_count()  # 当前处于alive状态的线程个数.")]),n._v(" "),e("li",[n._v("enumerate()  # 返回所有活着的线程的列表，不包括已经终止的线程和未开始的线程.")]),n._v(" "),e("li",[n._v("get_ident()  # 返回当前线程ID，非0整数.")])])},function(){var n=this.$createElement,t=this._self._c||n;return t("ul",[t("li",[this._v("name: 只是一个名称标识，可以重名，getName()、setName()来获取、设置这个名词。")]),this._v(" "),t("li",[this._v("ident: 线程ID，它是非0整数。线程启动后才会有ID，否则为None。线程退出，此ID依旧可以访问。此ID可以重复使用。")]),this._v(" "),t("li",[this._v("is_alive(): 返回线程是否活着。")])])},function(){var n=this.$createElement,t=this._self._c||n;return t("p",[t("code",[this._v("t = threading.Thread(target=func, name='my_thread', args=('1', ), kwargs={'a': 2})")])])},function(){var n=this.$createElement,t=this._self._c||n;return t("ul",[t("li",[this._v("start(): 启动线程。每一个线程必须且只能执行该方法一次。")])])},function(){var n=this.$createElement,t=this._self._c||n;return t("ul",[t("li",[this._v("run(): 运行线程函数。")])])},function(){var n=this.$createElement,t=this._self._c||n;return t("p",[this._v("可以看到，run就是去调用函数，谁来调用呢？当然是"),t("code",[this._v("当前线程")]),this._v("了，可以看到 "),t("code",[this._v("print(threading.main_thread().name, threading.current_thread().name, threading.current_thread().ident)")]),this._v(" 打印出来的都是主线程。")])},function(){var n=this.$createElement,t=this._self._c||n;return t("p",[t("strong",[this._v("没有开新的线程，这就是普通函数调用，所以执行完t1.run()，然后执行t2.run()，这里就不是多线程。")])])},function(){var n=this.$createElement,t=this._self._c||n;return t("p",[this._v("一个进程中至少有一个线程，并作为程序的入口，这个线程就是主线程。一个进程至少有一个"),t("code",[this._v("主线程")]),this._v("。其他线程称为"),t("code",[this._v("工作线程")]),this._v("。")])},function(){var n=this.$createElement,t=this._self._c||n;return t("p",[t("code",[this._v("def print(self, *args, sep=' ', end='\\n', file=None)")])])},function(){var n=this.$createElement,t=this._self._c||n;return t("p",[this._v('线程可以被标识为"Daemon线程"，'),t("strong",[this._v("Daemon线程表明整个Python主程序只有在Daemon子线程运行时可以退出")]),this._v("。该属性值继承自父线程，可通过setDaemon()函数设定该值。")])},function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ul",[e("li",[n._v("进程靠线程执行代码，至少有一个主线程，其他线程是工作线程。")]),n._v(" "),e("li",[n._v("主线程是第一个启动的线程。")]),n._v(" "),e("li",[n._v("父线程：如果线程A中启动了一个线程B，A就是B的父线程。")]),n._v(" "),e("li",[n._v("子线程：B就是A的子线程。")]),n._v(" "),e("li",[n._v("python中构造线程的时候可以设置daemon属性，这个属性必须在start方法之前设置好。")])])},function(){var n=this.$createElement,t=this._self._c||n;return t("div",{staticClass:"tip custom-block"},[t("p",{staticClass:"custom-block-title"},[this._v("TIP")]),this._v(" "),t("p",[this._v("daemon=False 运行发现子线程依然执行，主线程已经执行完，但是主线程会一直等着子线程执行完\ndaemon=True 运行发现主线程执行完程序立即结束了")])])},function(){var n=this.$createElement,t=this._self._c||n;return t("ul",[t("li",[this._v("如果有non-daemon线程的时候，主线程退出时，也不会杀掉所有daemon线程，直到所有non-daemon线程全部结束")]),this._v(" "),t("li",[this._v("如果还有daemon线程，主线程需要退出，会结束所有 daemon线程，退出。")])])},function(){var n=this.$createElement,t=this._self._c||n;return t("p",[this._v("线程创建的时候"),t("code",[this._v("t = threading.Thread(target=func, daemon=False)")]),this._v("这个daemon不设置就是False")])},function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ul",[e("li",[n._v("使用了join方法后，daemon线程执行完了，主线程才退出。")]),n._v(" "),e("li",[n._v("join(timeout=None)，是线程的标准方法之一。")]),n._v(" "),e("li",[n._v("一个线程中调用另一个线程的join方法，调用者将被阻塞，直到被调用线程终止。")]),n._v(" "),e("li",[n._v("一个线程可以被join多次。")]),n._v(" "),e("li",[n._v("timeout参数指定调用者等待多久，没有设置超时，就一直等待被调用线程结束。")]),n._v(" "),e("li",[n._v("调用谁的join方法，就是join谁，就要等谁。")])])},function(){var n=this.$createElement,t=this._self._c||n;return t("p",[this._v("把上面例子的 "),t("code",[this._v("t1.join() # 设置join.")]),this._v(" 放开，"),t("code",[this._v("print('Main Thread Exiting')")]),this._v(" 要等子线程执行完成才执行。")])},function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("div",{staticClass:"language-py extra-class"},[e("pre",{pre:!0,attrs:{class:"language-py"}},[e("code",[e("span",{attrs:{class:"token keyword"}},[n._v("import")]),n._v(" dis\ndis"),e("span",{attrs:{class:"token punctuation"}},[n._v(".")]),n._v("dis"),e("span",{attrs:{class:"token punctuation"}},[n._v("(")]),n._v("foo"),e("span",{attrs:{class:"token punctuation"}},[n._v(")")]),n._v("\n")])])])},function(){var n=this.$createElement,t=this._self._c||n;return t("p",[t("code",[this._v("q = queue.Queue(3) # 创建队列，队列最大元素3个，默认为0，此时队列长度没有限制")])])},function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ul",[e("li",[n._v("queue.qsize() 返回队列的大小")]),n._v(" "),e("li",[n._v("queue.empty() 如果队列为空，返回True，反之False")]),n._v(" "),e("li",[n._v("queue.full() 如果队列满了，返回True，反之False")]),n._v(" "),e("li",[n._v("queue.full 与 maxsize 大小对应")]),n._v(" "),e("li",[n._v("queue.get([block[, timeout]])获取队列，timeout等待时间")]),n._v(" "),e("li",[n._v("queue.get_nowait() 相当queue.get(False)")]),n._v(" "),e("li",[n._v("queue.put(item) 写入队列，timeout等待时间")]),n._v(" "),e("li",[n._v("queue.put_nowait(item) 相当queue.put(item, False)")]),n._v(" "),e("li",[n._v("queue.task_done() 在完成一项工作之后，queue.task_done()函数向任务已经完成的队列发送一个信号")]),n._v(" "),e("li",[n._v("queue.join() 实际上意味着等到队列为空，再执行别的操作")])])},function(){var n=this.$createElement,t=this._self._c||n;return t("ol",[t("li",[t("p",[this._v("协同式多任务处理\n当一项任务比如网络 I/O启动，而在长的或不确定的时间，没有运行任何 Python 代码的需要，一个线程便会让出GIL，从而其他线程可以获取 GIL 而运行 Python。这种礼貌行为称为协同式多任务处理，它允许并发；多个线程同时等待不同事件。")])]),this._v(" "),t("li",[t("p",[this._v("抢占式多任务处理\nPython线程可以主动释放 GIL，也可以先发制人抓取 GIL 。")])])])}],!1,null,null,null);a.options.__file="README.md";t.default=a.exports}}]);