(window.webpackJsonp=window.webpackJsonp||[]).push([[57],{508:function(e,t,n){"use strict";n.r(t);var r=n(1),s=Object(r.a)({},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"content"},[n("h1",{attrs:{id:"flask"}},[e._v("Flask")]),e._v(" "),e._m(0),e._v(" "),n("h2",{attrs:{id:"关于扩展"}},[e._v("关于扩展")]),e._v(" "),n("p",[e._v("通过安装对应的扩展包，可以扩展框架的很多功能（这些扩展和框架会有结合，有点想开启框架的功能一样），Flask的扩展都暴露在flask.ext命名空间下，你可以在环境中通过pip安装好相应扩展，然后再在程序中导入相应的包即可使用扩展。")]),e._v(" "),e._m(1),e._v(" "),n("h2",{attrs:{id:"自定义url转换器"}},[e._v("自定义url转换器")]),e._v(" "),e._m(2),e._v(" "),n("highlight-code",{attrs:{lang:"python"}},[n("pre",[n("code",[e._v("from urllib import parse\n\nfrom flask import Flask\nfrom werkzeug.routing import BaseConverter\n\napp = Flask(__name__)\n\n\nclass ListConverter(BaseConverter):\n\n    def __init__(self, url_map, separator='+'):\n        super(ListConverter, self).__init__(url_map)\n        self.separator = parse.unquote(separator)  # unquote 对url进行解码\n\n    def to_python(self, value):\n        return value.split(self.separator)\n\n    def to_url(self, values):\n        return self.separator.join(BaseConverter.to_url(self, value)\n                                for value in values)\n\n\napp.url_map.converters['list'] = ListConverter\n\n\n@app.route('/list1/<list:page_names>/')\ndef list1(page_names):\n    print(page_names)\n    return 'Separator: {} {}'.format('+', page_names)\n\n\n@app.route('/list2/<list(separator=u\"|\"):page_names>/')\ndef list2(page_names):\n    return 'Separator: {} {}'.format('|', page_names)\n\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=9000)\n")])])]),e._v(" "),n("h2",{attrs:{id:"唯一url"}},[e._v("唯一url")]),e._v(" "),e._m(3),e._v(" "),n("h2",{attrs:{id:"扩展响应"}},[e._v("扩展响应")]),e._v(" "),e._m(4),e._v(" "),n("h2",{attrs:{id:"静态文件管理"}},[e._v("静态文件管理")]),e._v(" "),e._m(5),e._v(" "),n("h2",{attrs:{id:"关于视图"}},[e._v("关于视图")]),e._v(" "),n("p",[e._v("通常使用函数视图，但是这样就发挥不出类的作用了，比如继承一个基类，定义一些基础的东西，flask也可以使用基于类的视图")]),e._v(" "),n("h3",{attrs:{id:"标准类视图"}},[e._v("标准类视图")]),e._v(" "),e._m(6),e._v(" "),n("highlight-code",{attrs:{lang:"python"}},[n("pre",[n("code",[e._v("from flask.views import View\nclass PersonalView(View):\n    def dispatch_request(self):\n        return \"hello\"\n\napp.add_url_rule('/users/',view_func=PersonalView.as_view('personalview'))\n")])])]),e._v(" "),n("h3",{attrs:{id:"基于调度方法的视图"}},[e._v("基于调度方法的视图")]),e._v(" "),e._m(7),e._v(" "),n("highlight-code",{attrs:{lang:"python"}},[n("pre",[n("code",[e._v("from flask import Flask, jsonify\nfrom flask.views import MethodView\nfrom flask import session\n\napp = Flask(__name__)\n\n\ndef login_required(func):\n    def wrapper(*args, **kwargs):\n        if not session.get(\"user_id\"):\n            return 'auth failure'\n        return func(*args, **kwargs)\n\n    return wrapper\n\n\nclass UserAPI(MethodView):\n    decorators = [login_required]\n\n    def get(self):\n        return jsonify({\n            'username': 'fake',\n            'avatar': 'http://lorempixel.com/100/100/nature/'\n        })\n\n    def post(self):\n        return 'UNSUPPORTED!'\n\n\napp.add_url_rule('/user', view_func=UserAPI.as_view('userview'))\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=9000)\n")])])]),e._v(" "),n("h2",{attrs:{id:"使用命令行接口"}},[e._v("使用命令行接口")]),e._v(" "),e._m(8),e._v(" "),e._m(9),e._v(" "),n("highlight-code",{attrs:{lang:"python"}},[n("pre",[n("code",[e._v("@app.cli.command()\ndef run_test():\n    print('this is a test script')\n")])])]),e._v(" "),n("h2",{attrs:{id:"context"}},[e._v("Context")]),e._v(" "),n("p",[e._v("理解请求上下文和应用上下文。")]),e._v(" "),n("h2",{attrs:{id:"werkzeug"}},[e._v("werkzeug")]),e._v(" "),n("p",[e._v("WSGI 协议工具集")]),e._v(" "),n("h2",{attrs:{id:"配置参数讲解"}},[e._v("配置参数讲解")]),e._v(" "),n("p",[e._v("创建app需要传递配置参数，以供各个模块使用")]),e._v(" "),n("p",[e._v("SECRET_KEY：密码加盐的参数，推荐设置成系统变量")]),e._v(" "),n("h2",{attrs:{id:"扩展模块"}},[e._v("扩展模块")]),e._v(" "),n("p",[e._v("扩展模块很多是基于现有的模块做扩展，封装成flask的扩展，比如把实例加入请求上下文中；模块的更多用法可以参考原模块。")]),e._v(" "),n("p",[e._v("需要分析用法的模块，列出项目地址。")]),e._v(" "),n("h3",{attrs:{id:"flask-script"}},[e._v("flask_script")]),e._v(" "),e._m(10),e._v(" "),e._m(11),e._v(" "),n("p",[e._v("由于是弃用的模块，不再赘述。")]),e._v(" "),n("h3",{attrs:{id:"flask-migrate"}},[e._v("flask_migrate")]),e._v(" "),n("p",[e._v("Flask-Migrate是用于处理SQLAlchemy 数据库迁移的扩展工具。当Model出现变更的时候，通过migrate去管理数据库变更。依赖alembic模块。")]),e._v(" "),n("p",[e._v("用法：")]),e._v(" "),n("highlight-code",{attrs:{lang:"python"}},[n("pre",[n("code",[e._v("from flask import Flask\nfrom flask_sqlalchemy import SQLAlchemy\nfrom flask_migrate import Migrate\n\napp = Flask(__name__)\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///app.db'\n\ndb = SQLAlchemy(app)\nmigrate = Migrate(app, db)\n")])])]),e._v(" "),n("p",[e._v("命令：")]),e._v(" "),e._m(12),e._v(" "),n("p",[e._v("由于migrate并不一定全部发现你对model的所有改动，因此生成的py脚本需要review, 有错的话则需要edit。")]),e._v(" "),n("p",[e._v("例如目前知道的，表名称表更，列名称变更，或给constraints命名等，migreate都不能发现的。更多限制细节见此：Alembic autogenerate documentation。")]),e._v(" "),n("p",[e._v("在Alembic 中，数据库迁移用迁移脚本表示。脚本中有两个函数，分别是upgrade() 和downgrade()。upgrade() 函数把迁移中的改动应用到数据库中，downgrade() 函数则将改动删除。Alembic 具有添加和删除改动的能力，因此数据库可重设到修改历史的任意一点。")]),e._v(" "),n("p",[e._v("我们可以使用revision 命令手动创建Alembic 迁移，也可使用migrate 命令自动创建。手动创建的迁移只是一个骨架，upgrade() 和downgrade() 函数都是空的，开发者要使用Alembic 提供的Operations 对象指令实现具体操作。自动创建的迁移会根据模型定义和数据库当前状态之间的差异生成upgrade() 和downgrade() 函数的内容。自动创建的迁移不一定总是正确的，有可能会漏掉一些细节。自动生成迁移脚本后一定要进行检查。")]),e._v(" "),n("p",[e._v("查看帮助文档：flask db --help")]),e._v(" "),n("p",[e._v("运行flask db init后，提示配置日志输出，默认输出到终端，应该配置日志到文件，方便以后排查问题（看看是谁动了数据库）")]),e._v(" "),n("h2",{attrs:{id:"flask-logging"}},[e._v("flask_logging")]),e._v(" "),n("p",[n("a",{attrs:{href:"https://github.com/dgilland/flask-logconfig",target:"_blank",rel:"noopener noreferrer"}},[e._v("GitHub"),n("OutboundLink")],1)])],1)},[function(){var e=this.$createElement,t=this._self._c||e;return t("p",[t("img",{attrs:{src:"/my-notebook/images/Python/Flask.png",alt:"image"}})])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("在新的版本中，引入flask扩展不能再从flask.ext导入了，直接从安装模块导入，比如 "),t("code",[this._v("from flask_sqlalchemy import SQLAlchemy")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("在路由中，使用<>来获取动态参数，默认是字符串类型的，如果想要指定参数类型，需要标记成"),t("code",[this._v("<converter:variable_name>")]),this._v(" 这样的格式，类似 "),t("code",[this._v("<int:quantity>")]),this._v("，使用any可以指定多种路径，类似"),t("code",[this._v("<any(a, b:page_name)>")]),this._v("。像any，int做为类型可以自定义，比如定义list类型，代码如下：")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("在路由的装饰器中，如果指定了结尾的反斜杠，类似这样的路径 "),t("code",[this._v("\\page\\")]),this._v("，那么浏览器访问地址以反斜杠结尾，或者没有反斜杠都可以访问(访问一个不以反斜杠结尾的url会被重定向到到反斜杠的url上)，如果路由是"),t("code",[this._v("\\page")]),this._v("，那么浏览器访问以反斜杠结尾会报错。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("这是一个很常见的需求，对返回对象进行包装，比如返回一个ORM的查询实例，这个是不能被json序列化的，通过扩展返回数据，可以对特定对象进行处理。另一种情况，是重写响应类，"),t("code",[this._v("app.response = JSONResponse")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("在创建flask实例的时候，通过static_folder修改默认静态文件路径，"),t("code",[this._v("Flask(__name__, static_folder='/tmp')")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("标准类视图是继承自 "),t("code",[this._v("flask.views.View")]),this._v("，并且在子类中必须实现 "),t("code",[this._v("dispatch_request")]),this._v(" 方法，这个方法类似于视图函数，也要返回一个基于Response或者其子类的对象。通过 "),t("code",[this._v("app.add_url_rule(url_rule, view_func)")]),this._v(" 来进行注册")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("继承自 "),t("code",[this._v("flask.views.MethodView")]),this._v("，可以对不同的HTTP方法执行对应的函数，使用方法的小写名。在类视图中定义一个属性叫做decorators，然后存储装饰器。以后每次调用这个类视图的时候，就会执行这个装饰器")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("和Django一样，flask框架也提供了很多命令，flask命令需要添加都环境变量，这个一般在安装后就有了。然后需要设置flask应用的环境变量，可以使用 "),t("code",[this._v("export FLASK_APP='app.py path'")]),this._v(" 。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("也可以自定义命令，比如 "),t("code",[this._v("flask run_test")]),this._v(" 执行一个测试脚本，代码如下：")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("用来自定义命令的，不过模块没有维护了，官方也推荐不要再使用它了，推荐使用 "),t("code",[this._v("@app.cli.command")]),this._v(" 的形式来添加命令。然后配置环境变量，通过flask command的形式来执行命令。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("可以使用装饰器，和类来添加命令。装饰器："),t("code",[this._v("@manager.command")]),this._v("；类：继承Command类，实现run方法。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("ol",[t("li",[t("p",[this._v("初始化\nflask db init\n这个命令会在当前目录下生成一个migrations文件夹。这个文件夹也需要和其他源文件一起，添加到版本控制。")])]),this._v(" "),t("li",[t("p",[this._v("生成最初的迁移\nflask db migrate\n此命令会在migrations下生成一个version文件夹，下面包含了对应版本的数据库操作py脚本。")])]),this._v(" "),t("li",[t("p",[this._v("数据库升级\nflask db upgrade\n最后一步。此命令相当于执行了version文件夹下的相应py版本，对数据库进行变更操作。此后，对model有变更，只要重复migrate和upgrade操作即可。")])])])}],!1,null,null,null);s.options.__file="Flask.md";t.default=s.exports}}]);