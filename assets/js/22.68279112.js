(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{473:function(t,e,a){"use strict";a.r(e);var s=a(1),n=Object(s.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("div",{staticClass:"content"},[a("h1",{attrs:{id:"docker-笔记"}},[t._v("Docker 笔记")]),t._v(" "),a("hr"),t._v(" "),a("p",[a("img",{attrs:{src:"/my-notebook/images/docker/docker.png",alt:"image"}})]),t._v(" "),a("h2",{attrs:{id:"命令"}},[t._v("命令")]),t._v(" "),a("pre",[a("code",[t._v("docker ps 列出容器列表\ndocker container ls 管理容器\n")])]),t._v(" "),a("p",[t._v("两个命令都是查看正在运行的容器，加 -a 参数可以查看更多的信息")]),t._v(" "),a("pre",[a("code",[t._v("docker run     docker container run   都是运行容器(但是本质还是不同的，可以深入研究下)\nCtrl+P+Q  退出容器不关闭\n\ndocker start goofy_almeida  启动容器在后台运行\ndocker attach goofy_almeida 后台容器进入终端\n\ndocker network create <name>\ndocker network inspect <name>\n\ndocker stats 容器ID  查看容器状态\ndocker logs 把容器运行后产生的输入都打印出来，不要轻易尝试\n")])]),t._v(" "),a("h3",{attrs:{id:"多个终端访问容器"}},[t._v("多个终端访问容器")]),t._v(" "),a("p",[t._v("有时候需要开启多个终端来访问容器，通过容器ID，执行命令 "),a("code",[t._v("docker exec -it 40c330755e61 /bin/bash")]),t._v(" 就可以了，这个终端的退出不会影响到已经开启的终端")]),t._v(" "),a("h3",{attrs:{id:"创建容器的参数"}},[t._v("创建容器的参数")]),t._v(" "),a("ul",[a("li",[t._v("-d：后台运行容器，并返回容器ID")]),t._v(" "),a("li",[t._v("-i：以交互模式运行容器，通常与 -t 同时使用")]),t._v(" "),a("li",[t._v("-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用")])]),t._v(" "),a("h2",{attrs:{id:"容器连接"}},[t._v("容器连接")]),t._v(" "),a("p",[t._v("容器连接就是把容器接到一起，让它们可以相互通信，如果你使用一个容器运行一个软件的方式，容器连接就是很有必要的，比如你的服务和数据库进行通信，那么你的容器就要连接在一起。\n使用到的命令有 "),a("code",[t._v("--link")]),t._v(" ，不过新的特性推荐使用 "),a("code",[t._v("network")]),t._v(" ，network把容器都加到一个网络中，实现之间的互相通信。")]),t._v(" "),a("h3",{attrs:{id:"相关命令"}},[t._v("相关命令")]),t._v(" "),a("hr"),t._v(" "),a("ol",[a("li",[t._v("创建网络，"),a("code",[t._v("my_network")]),t._v(" 是网络的名称。创建完网络，把容器加入到网络就行了。")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("docker network create my_network\n")])])]),a("p",[t._v("tip 加入网络示例：")]),t._v(" "),a("p",[a("code",[t._v("docker run -it --name=web_django --network web_network --network-alias django -v /root/py_web_vadmin/:/root/web_work -p 8080:8080 debian:v2 bash")])]),t._v(" "),a("p",[a("code",[t._v("docker run -it --name=web_nginx --network web_network --network-alias nginx -v /root/py_web_vadmin/:/root/web_work -p 80:80 nginx bash")])]),t._v(" "),a("p",[t._v("把debian和nginx加入到一个已创建的网络中。")]),t._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[t._v("查看网络")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("docker network ls 查看已创建的网络，默认有服务自己创建的网络\n")])])]),a("p",[t._v("效果如下：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("NETWORK ID      NAME    DRIVER  SCOPE\n9872c9881f6e    bridge  bridge  local\n6fc119c0ceda    host    host    local\nc3fdf8d5c56e    none    null    local \n")])])]),a("ul",[a("li",[t._v("bridge：默认网络，所有容器默认连接到它")]),t._v(" "),a("li",[t._v("none：没有网络接口")]),t._v(" "),a("li",[t._v("host：连接到主机的网络栈，主机和容器间的网络没有隔离")])]),t._v(" "),a("h2",{attrs:{id:"数据卷"}},[t._v("数据卷")]),t._v(" "),a("p",[t._v("数据卷用来做数据持久化，如果你的数据在容器中，比如数据库文件，日志文件等，这些文件是会不断生成的，当你关闭容器，再次启动容器，数据倒是不会丢失，如果你从镜像启动新的容器，数据就没了（出现这种情况是因为：通常使用run命令来启动容器，如果没有定义name，那么每次使用run命令都会从镜像创建新的容器，这样上次容器的操作都没了，应该养成定义容器name的习惯，创建同名的容器是不允许的）。数据要想保持，除非你不断的提交镜像，当然这种做法是不可取的，所以要用到数据卷技术。数据可以让容器和宿主主机共享一个目录，通常把程序，数据库文件等放在宿主机上，通过创建数据卷，让容器可以操作到宿主机文件，并把新的数据写到此。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("docker container run -v /root/data:/root/PythonProjects/GitTest -it -p 8080:8080 debian:v2 bash\n")])])]),a("p",[t._v("上面命令的含意是：本机目录/root/data映射到容器目录/root/PythonProjects/GitTest（在启动容器的时候就得使用-v 命令，容器和主机共用一个目录，关闭容器，在启动容器也得带-v命令）\n一般会把程序放在宿主机上，更新修改都在这，不过修改了代码后，记得进入容器中去重启项目。")]),t._v(" "),a("h2",{attrs:{id:"文件操作"}},[t._v("文件操作")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("从主机复制到容器 sudo docker cp host_path containerID:container_path\n从容器复制到主机 sudo docker cp containerID:container_path host_path\n")])])]),a("p",[t._v("操作流程：先把容器运行起来，宿主主机执行 docker container 查询正在运行的container 的containerID 然后去执行上面的命令")]),t._v(" "),a("p",[t._v("保存容器修改：")]),t._v(" "),a("ul",[a("li",[t._v("pull 了一个新的image后，或操作已有的容器，并对容器做了修改，退出容器后")]),t._v(" "),a("li",[t._v("执行 docker ps -l 得到 容器的ID")]),t._v(" "),a("li",[t._v("执行 docker commit 容器ID 镜像名称 该操作将覆盖现有进行为修改后的容器")]),t._v(" "),a("li",[t._v("docker commit 容器ID 镜像名称:v2 保存修改为tag为v2的镜像")])]),t._v(" "),a("h2",{attrs:{id:"容器"}},[t._v("容器")]),t._v(" "),a("p",[t._v("容器(container)是docker一个很重要的概念，通过镜像我们就可以创建容器。这里记录一些相关命令。")]),t._v(" "),a("div",{staticClass:"language-vim extra-class"},[a("pre",{pre:!0,attrs:{class:"language-vim"}},[a("code",[t._v("查看\ndocker container "),a("span",{attrs:{class:"token keyword"}},[t._v("ls")]),t._v(" 等同于 docker "),a("span",{attrs:{class:"token keyword"}},[t._v("ps")]),t._v("  "),a("span",{attrs:{class:"token operator"}},[t._v("-")]),t._v("a 查看更多的信息\n\n删除\ndocker rm  container id\ndocker rmi  image id\n\n杀死所有正在运行的容器\ndocker kill $"),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("docker "),a("span",{attrs:{class:"token keyword"}},[t._v("ps")]),t._v(" "),a("span",{attrs:{class:"token operator"}},[t._v("-")]),t._v("a "),a("span",{attrs:{class:"token operator"}},[t._v("-")]),a("span",{attrs:{class:"token keyword"}},[t._v("q")]),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n删除所有已经停止的容器"),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("容器不再使用了，可以使用此命令把它们都清空了"),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\ndocker rm $"),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("docker "),a("span",{attrs:{class:"token keyword"}},[t._v("ps")]),t._v(" "),a("span",{attrs:{class:"token operator"}},[t._v("-")]),t._v("a "),a("span",{attrs:{class:"token operator"}},[t._v("-")]),a("span",{attrs:{class:"token keyword"}},[t._v("q")]),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n删除所有未打 dangling 标签的镜像\ndocker rmi $"),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("docker images "),a("span",{attrs:{class:"token operator"}},[t._v("-")]),a("span",{attrs:{class:"token keyword"}},[t._v("q")]),t._v(" "),a("span",{attrs:{class:"token operator"}},[t._v("-")]),a("span",{attrs:{class:"token keyword"}},[t._v("f")]),t._v(" dangling"),a("span",{attrs:{class:"token operator"}},[t._v("=")]),t._v("true"),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n删除所有镜像\ndocker rmi $"),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("docker images "),a("span",{attrs:{class:"token operator"}},[t._v("-")]),a("span",{attrs:{class:"token keyword"}},[t._v("q")]),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n强制删除镜像名称中包含“doss"),a("span",{attrs:{class:"token operator"}},[t._v("-")]),t._v("api”的镜像\ndocker rmi "),a("span",{attrs:{class:"token operator"}},[t._v("-")]),a("span",{attrs:{class:"token operator"}},[t._v("-")]),t._v("force $"),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("docker images | "),a("span",{attrs:{class:"token keyword"}},[t._v("grep")]),t._v(" doss"),a("span",{attrs:{class:"token operator"}},[t._v("-")]),t._v("api | awk "),a("span",{attrs:{class:"token string"}},[t._v("'{print $3}'")]),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n删除所有未使用数据\ndocker system prune\n\n只删除未使用的volumes\ndocker volume prune\n\ndocker start goofy_almeida  启动容器在后台运行\ndocker attach goofy_almeida 后台容器进入终端\n")])])]),a("h3",{attrs:{id:"docker-ps-选项"}},[t._v("docker ps --选项")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("Name, shorthand")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("Default")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("Description")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("--all , -a")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}}),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("Show all containers (default shows just running)")])]),t._v(" "),a("tr",[a("td",[t._v("--filter , -f")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}}),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("Filter output based on conditions provided")])]),t._v(" "),a("tr",[a("td",[t._v("--format")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}}),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("Pretty-print containers using a Go template")])]),t._v(" "),a("tr",[a("td",[t._v("--last , -n")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("-1")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("Show n last created containers (includes all states)")])]),t._v(" "),a("tr",[a("td",[t._v("--latest , -l")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}}),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("Show the latest created container (includes all states)")])]),t._v(" "),a("tr",[a("td",[t._v("--no-trunc")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}}),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("Don’t truncate output")])]),t._v(" "),a("tr",[a("td",[t._v("--quiet , -q")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}}),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("Only display numeric IDs")])]),t._v(" "),a("tr",[a("td",[t._v("--size , -s")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}}),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("Display total file sizes")])])])]),t._v(" "),a("p",[t._v("使用 "),a("code",[t._v("docker attach")]),t._v(" 命令进入container（容器）有一个缺点，那就是每次从container中退出到前台时，container也跟着退出了。\n要想退出container时，让container仍然在后台运行着，可以使用 "),a("code",[t._v("docker exec -it")]),t._v(" 命令。每次使用这个命令进入container，当退出container后，container仍然在后台运行，命令使用方法：")]),t._v(" "),a("div",{staticClass:"language-s extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("docker exec -it goofy_almeida /bin/bash\n\ngoofy_almeida：要启动的container的名称\n\n/bin/bash：在container中启动一个bash shell\n")])])]),a("p",[t._v("这样输入“exit”或者按键“Ctrl + C”退出container时，这个container仍然在后台运行。")]),t._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),a("p",[t._v("关于容器的运行，我本人的做法会使用 "),a("code",[t._v("screen")]),t._v(" (linux的一个软件)，一般没有做后台运行。")])]),t._v(" "),a("h3",{attrs:{id:"container总结"}},[t._v("container总结")]),t._v(" "),a("p",[t._v("run 命令后从镜像创建container(容器)，此时的容器是新的，如果修改了内容，用exit退出，这个容器被关闭了（进入了Exited状态），如果想留着修改，最好是Ctrl+P+Q  退出容器不关闭  这样docker ps  可以查看容器还在，这样就可以通过start 容器name再次进入容器了。（这里我感觉容器的状态是有用的，具体就要看文档了，因为run新容器后，通过exit命令退出了，再次run，此时ps命令应该是创建了一次，然后关闭，又创建了一次，出现过两个name, 但是第二次run的容器是新的，上次修改的拿不到。 但是修改后，exit退出，通过docker ps -l，可以看到容器id,  这里可以进行提交。所以像保持容器的修改，最好用上面的流程，等理清楚了生命周期，就比较清楚整个流程了）经测试，docker ps -l列不出的容器，通过docker ps -a找到，即使状态不是update也可以去commit。")]),t._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("容器的status")]),t._v(" "),a("p",[t._v("One of created, restarting, running, removing, paused, exited, or dead")])]),t._v(" "),a("h2",{attrs:{id:"容器导入导出"}},[t._v("容器导入导出")]),t._v(" "),a("pre",[a("code",[t._v("docker save imageID > filename.tar\ndocker load < filename.tar\n\ndocker export imageID > filename.tar\ndocker import < filename.tar\n")])]),t._v(" "),a("p",[t._v("镜像和容器导出和导入的区别")]),t._v(" "),a("p",[t._v("镜像导入和容器导入的区别：")]),t._v(" "),a("ol",[a("li",[t._v("容器导入 是将当前容器 变成一个新的镜像")]),t._v(" "),a("li",[t._v("镜像导入 是复制的过程")])]),t._v(" "),a("p",[t._v("save 和 export区别：")]),t._v(" "),a("ol",[a("li",[t._v("save 保存镜像所有的信息-包含历史")]),t._v(" "),a("li",[t._v("export 只导出当前的信息")])]),t._v(" "),a("h2",{attrs:{id:"dockerfile-使用"}},[t._v("Dockerfile 使用")]),t._v(" "),a("p",[t._v("除了通过拉取官方镜像的方式外，使用Dockerfile可以定制镜像，使其更加灵活。\n整个Dockerfile文件就是执行的脚本，由特定的命令组成，一个redis镜像Dockerfile文件大概是这样的。")]),t._v(" "),a("div",{staticClass:"language-vim extra-class"},[a("pre",{pre:!0,attrs:{class:"language-vim"}},[a("code",[t._v("FROM centos"),a("span",{attrs:{class:"token punctuation"}},[t._v(":")]),t._v("latest\n\nRUN yum "),a("span",{attrs:{class:"token operator"}},[t._v("-")]),a("span",{attrs:{class:"token keyword"}},[t._v("y")]),t._v(" "),a("span",{attrs:{class:"token keyword"}},[t._v("update")]),a("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" yum clean "),a("span",{attrs:{class:"token keyword"}},[t._v("all")]),t._v("\nRUN yum "),a("span",{attrs:{class:"token operator"}},[t._v("-")]),a("span",{attrs:{class:"token keyword"}},[t._v("y")]),t._v(" install epel"),a("span",{attrs:{class:"token operator"}},[t._v("-")]),t._v("release"),a("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" yum clean "),a("span",{attrs:{class:"token keyword"}},[t._v("all")]),t._v("\nRUN yum "),a("span",{attrs:{class:"token operator"}},[t._v("-")]),a("span",{attrs:{class:"token keyword"}},[t._v("y")]),t._v(" install redis"),a("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" yum clean "),a("span",{attrs:{class:"token keyword"}},[t._v("all")]),t._v("\n\n# 设置挂载点\nVOLUME "),a("span",{attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{attrs:{class:"token string"}},[t._v('"/data/redis"')]),a("span",{attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n\n# Define working "),a("span",{attrs:{class:"token builtin"}},[t._v("directory")]),a("span",{attrs:{class:"token operator"}},[t._v(".")]),t._v("\nWORKDIR "),a("span",{attrs:{class:"token operator"}},[t._v("/")]),t._v("data\n\nEXPOSE "),a("span",{attrs:{class:"token number"}},[t._v("6379")]),t._v("\n\nCMD "),a("span",{attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{attrs:{class:"token string"}},[t._v('"redis-server"')]),a("span",{attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n")])])]),a("p",[t._v("上述Dockerfile文件是基于基础镜像CentOS来制作Redis。")]),t._v(" "),a("p",[a("code",[t._v("docker build -t centos:v2 .")]),t._v(" 在文件所在目录下执行构建命令")]),t._v(" "),a("h3",{attrs:{id:"指令"}},[t._v("指令")]),t._v(" "),a("p",[t._v("Dockerfile指令就是上述文件中开头的FROM，RUN等。Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像。")]),t._v(" "),a("p",[t._v("FROM scratch 如果你以 scratch 为基础镜像的话，意味着你不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。")]),t._v(" "),a("div",{staticClass:"language-vim extra-class"},[a("pre",{pre:!0,attrs:{class:"language-vim"}},[a("code",[t._v("ADD\nCOPY\nENV\nEXPOSE\nFROM\nLABEL\nSTOPSIGNAL\nUSER\nVOLUME\nWORKDIR\n")])])]),a("h2",{attrs:{id:"docker-compose"}},[t._v("docker-compose")]),t._v(" "),a("p",[t._v("这个工具是用来做容器编排的，简单来说就是可以一次启动多个容器，包括了设置端口映射，数据卷，容器连接等。在使用docker部署项目时，还是应该一个软件对应一个容器，而不是基于一个容器安装多个软件（这样就搞成一个虚拟机了），你要依次启动4，5个容器，设置端口映射，容器连接等会很麻烦，使用docker-compose只需要编写一个 "),a("code",[t._v("docker-compose.yaml")]),t._v(" 文件就可以了。")]),t._v(" "),a("p",[t._v("使用了docker-compose，最好再配合一下Dockerfile，这样很快速就可以搭建一个环境。")]),t._v(" "),a("p",[t._v("以Python语言为例，流程应该是编写Dockerfile，在Dockerfile中基于一个基本容器（ubuntu，或者是Python3等容器），设置一些参数，然后安装依赖 "),a("code",[t._v("RUN pip install -r requirements.txt")]),t._v("，这样语言环境就有了，下面就是各个服务，比如MySQL，Redis等，这些不是太复杂的情况，直接在Dockerfile中指定image就行了。")]),t._v(" "),a("p",[t._v("总结：")]),t._v(" "),a("ol",[a("li",[t._v("Dockerfile 定义应用的运行环境")]),t._v(" "),a("li",[t._v("docker-compose.yml 定义组成应用的各服务")]),t._v(" "),a("li",[t._v("docker-compose up 启动整个应用")])]),t._v(" "),a("h3",{attrs:{id:"编写yaml文件"}},[t._v("编写yaml文件")]),t._v(" "),a("p",[t._v("这个编写很简单，就是把各个容器怎么运行，参数配置组织在一起")]),t._v(" "),a("p",[t._v("来看一个简单的官方例子：")]),t._v(" "),a("div",{staticClass:"language-yaml extra-class"},[a("pre",{pre:!0,attrs:{class:"language-yaml"}},[a("code",[a("span",{attrs:{class:"token key atrule"}},[t._v("version")]),a("span",{attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{attrs:{class:"token string"}},[t._v("'3'")]),t._v("\n"),a("span",{attrs:{class:"token key atrule"}},[t._v("services")]),a("span",{attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),a("span",{attrs:{class:"token key atrule"}},[t._v("web")]),a("span",{attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),a("span",{attrs:{class:"token key atrule"}},[t._v("build")]),a("span",{attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" .\n    "),a("span",{attrs:{class:"token key atrule"}},[t._v("ports")]),a("span",{attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),a("span",{attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),a("span",{attrs:{class:"token string"}},[t._v('"5000:5000"')]),t._v("\n    "),a("span",{attrs:{class:"token key atrule"}},[t._v("volumes")]),a("span",{attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),a("span",{attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" ."),a("span",{attrs:{class:"token punctuation"}},[t._v(":")]),t._v("/code\n    "),a("span",{attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" logvolume01"),a("span",{attrs:{class:"token punctuation"}},[t._v(":")]),t._v("/var/log\n    "),a("span",{attrs:{class:"token key atrule"}},[t._v("links")]),a("span",{attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),a("span",{attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" redis\n  "),a("span",{attrs:{class:"token key atrule"}},[t._v("redis")]),a("span",{attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),a("span",{attrs:{class:"token key atrule"}},[t._v("image")]),a("span",{attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" redis\n"),a("span",{attrs:{class:"token key atrule"}},[t._v("volumes")]),a("span",{attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),a("span",{attrs:{class:"token key atrule"}},[t._v("logvolume01")]),a("span",{attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("官方文档总结：")]),t._v(" "),a("p",[t._v("一份标准配置文件应该包含 version、services、networks 三大部分，其中最关键的就是 services 和 networks 两个部分，官方这里的例子使用links，而没有使用新的networks特性。configs配置在3.3及以上版本使用，用于配置文件的访问权限。")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("version：用来指定版本，依照官方的例子，现在可以使用3版本了，不同版本对一些配置的支持不同，比如配置参数从字符串到对象的变化，这里不再深入了")])]),t._v(" "),a("li",[a("p",[t._v('services：就是需要运行的容器，容器通过build或image指定，build就是使用Dockerfile文件，image就是使用镜像，本地有的使用本地的，否则下载仓库的。build后面还可以加参数，例如context，args，用来设置上下文，参数等，这属于Dockerfile相关的内容，一般情况，直接在build指定当前目录就行了。ports指定端口映射，volums指定数据卷（使用数据卷，修改代码不用重启容器），在这个官方例子中，在最外层也就是顶级定义了volumes，这是为服务定义的，使用一个单机开发环境在services中定义就行了。标签有两种情况，在服务上（部署集群的时候）deploy: labels: ’标签内容‘，在容器上只需要用labels。看到deploy，它下面的配置都是和部署有关的。depends_on依赖关系，依赖的容器会先启动。command命令，类似python3 manage.py runserver 0.0.0.0:8000。pid: "host" 将PID模式设置为主机PID模式，跟主机系统共享进程命名空间。容器使用这个标签将能够访问和操纵其他容器和宿主机的名称空间。extra_hosts 添加主机名的标签，就是往/etc/hosts文件中添加一些记录，与Docker client的--add-host类似。')])])]),t._v(" "),a("h3",{attrs:{id:"命令-2"}},[t._v("命令")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("Command")]),t._v(" "),a("th",{staticStyle:{"text-align":"left"}},[t._v("Description")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("build")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("构建或重建服务，这会把Dockerfile再执行一次")])]),t._v(" "),a("tr",[a("td",[t._v("help")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("命令帮助")])]),t._v(" "),a("tr",[a("td",[t._v("kill")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("杀掉容器")])]),t._v(" "),a("tr",[a("td",[t._v("logs")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("显示容器的输出内容")])]),t._v(" "),a("tr",[a("td",[t._v("port")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("打印绑定的开放端口")])]),t._v(" "),a("tr",[a("td",[t._v("ps")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("显示容器")])]),t._v(" "),a("tr",[a("td",[t._v("pull")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("拉取服务镜像")])]),t._v(" "),a("tr",[a("td",[t._v("restart")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("重启服务")])]),t._v(" "),a("tr",[a("td",[t._v("rm")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("删除停止的容器")])]),t._v(" "),a("tr",[a("td",[t._v("run")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("运行一个一次性命令，run web bash")])]),t._v(" "),a("tr",[a("td",[t._v("exec")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("Execute a command in a running container，感觉run差不多")])]),t._v(" "),a("tr",[a("td",[t._v("scale")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("设置服务的容器数目")])]),t._v(" "),a("tr",[a("td",[t._v("start")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("开启服务")])]),t._v(" "),a("tr",[a("td",[t._v("stop")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("停止服务")])]),t._v(" "),a("tr",[a("td",[t._v("up")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("创建并启动容器")])]),t._v(" "),a("tr",[a("td",[t._v("version")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("查看版本，如果你是2版本的，就不要在yaml里面使用3版本的写法了")])])])]),t._v(" "),a("p",[t._v("使用总结：")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("个人心得，大致浏览了一下官方文档，docker-compose最大的用处应该是集群，它提供了很多功能，不过对于单机来说仍然有它的价值，省去了很多命令，同样作为单机来用，不需要学的很深入，很多配置都是用不到的")])]),t._v(" "),a("li",[a("p",[t._v("启动容器：使用up命令来启动容器，同时也会把build配置生成镜像，在我使用的版本中，给出了警告，对于需要使用Dockerfile构建的镜像，警告说应该先使用 "),a("code",[t._v("docker-compose up --build")]),t._v("，不过这对容器的启动到是没什么影响（不知道这里官方想表达什么）。build命令只会构建镜像，并不会去启动容器，up命令启动容器后，会把容器的输出打印到终端，要想在后台运行，应该 "),a("code",[t._v("up -d")])])]),t._v(" "),a("li",[a("p",[t._v("name：使用image的，镜像名称就是指定的，使用build，镜像名称为当前目录加上在services中的配置，在容器中的name也是当前目录加上在services中的配置。使用docker-compose需要在yaml文件目录执行，这样在services中的配置，比如一个叫做web的配置，第一次使用镜像（或用build构建）是Python，生成的容器也是 "),a("code",[t._v("当前目录_web_1")]),t._v("，修改了web配置，image变成Redis，那么上次创建的容器会被删除，创建新的容器，容器的名称是一样的，因为修改的是image，而不是web。使用container_name可以自定义容器name，不过通过ps命令可以看到系统的缺省名称是web_1，如果自定义了，那么在集群上因为名称相同导致错误")])]),t._v(" "),a("li",[a("p",[t._v("exited with code 0：我用自定义的dockerfile启动容器，结果返回这么一个信息容器就停止了，我分析了官方例子做了一些测试后发现，如果你的容器启动后，什么都不做，那就会退出了，一些情况也是会退出的，比如你用 "),a("code",[t._v("command echo $HOME")]),t._v(" 终端会打印这个信息，然后退出容器，我写了一个Python循环，用logging打印信息，终端一直在打印信息，没有退出。也就是说启动容器不能什么也不做")])]),t._v(" "),a("li",[a("p",[t._v("使用command，推荐绝对路径")])])]),t._v(" "),a("p",[t._v("☀️docker-compose应该这么来理解，它把多个容器组织在一起，并默认加到一个网络中（如果你没有定义网络或把容器分到不同的网络），通过run命令可以向整个环境发送命令，同时也可以使用docker的命令。体现了一个整体的概念。")])])}],!1,null,null,null);n.options.__file="README.md";e.default=n.exports}}]);