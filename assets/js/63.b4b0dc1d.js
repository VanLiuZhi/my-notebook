(window.webpackJsonp=window.webpackJsonp||[]).push([[63],{514:function(n,t,s){"use strict";s.r(t);var e=s(1),a=Object(e.a)({},function(){var n=this.$createElement,t=this._self._c||n;return t("div",{staticClass:"content"},[t("h1",{attrs:{id:"python-偷懒小工具"}},[this._v("python 偷懒小工具")]),this._v(" "),t("h2",{attrs:{id:"markdown-table-语法生成"}},[this._v("markdown table 语法生成")]),this._v(" "),t("highlight-code",{attrs:{lang:"python"}},[t("pre",[t("code",[this._v('"""\nmarkdown 的table语法格式 自动生成代码，错误的地方需要手动处理一下，中文因为字符占位问题，无法做到统一格式化\n"""\n\nop_str = \'\'\'\nv-bind ：动态绑定数据。简写为“:” 。=> 以后的:class="{red:boolean}"\nv-on ：绑定时间监听器。简写为“@”，例：@click="xxx"；\nv-text ：更新数据，会覆盖已有结构。类似'+this._s(this.msg)+" ；\nv-show ：根据值的真假，切换元素的display属性；\nv-if ：根据值的真假，切换元素会被销毁、重建； => 在dom中已消失\nv-else-if ：多条件判断，为真则渲染；\nv-else ：条件都不符合时渲染；\nv-for ：基于源数据多次渲染元素或模块；\nv-model ：在表单控件元素（input等）上创建双向数据绑定（数据源）；\nv-pre ：跳过元素和子元素的编译过程；\nv-once ：只渲染一次，随后数据更新也不重新渲染；\nv-cloak ：隐藏未编译的Mustache语法，在css中设置[v-cloak]{display:none;}\n'''\n\n_op_str = op_str.split('\\n')\n_op_str.pop()\nout_str = ''\nmax_str_len = len('v-else-if')  # pop(key[, default])\nspace = ' '\n\nfor item in _op_str:\n    tmp = item.split(' ')\n    if tmp[0] == '':\n        tmp_str = \"| Command{space} | Description \\n\".format(space=space * (max_str_len - len('Command')))\n        tmp_str += \"| {a} | :{b}: \\n\".format(a='-' * max_str_len, b='-' * (max_str_len - 2))\n    else:\n        tmp_str = \"| {a}{space} | {b} \\n\".format(a=tmp[0], b=''.join(tmp[1:]), space=space * (max_str_len - len(tmp[0])))\n    out_str += tmp_str\n\nprint(out_str)\n\n# print(len('Inheritor'))\n")])])])],1)},[],!1,null,null,null);a.options.__file="README.md";t.default=a.exports}}]);